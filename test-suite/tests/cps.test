(use-modules
 (test-suite lib)
 (language cps)
 (language cps compile-rtl)
 (language tree-il compile-cps))

;; a convenient way to write literal CPS code
(define-syntax-rule (cps x)
  (cps->program (parse-cps 'x)))

;; by-cps: compile a procedure, but by way of CPS instead of the normal
;; compiler chain
(define (by-cps x)
  (cps->program (tree-il->cps (compile x #:to 'tree-il))))

(pass-if "return-three"
  (= 3
     ((by-cps 3))))

(define (return-three) 3)

(pass-if "call-arg"
  (= 3
     ((by-cps '(lambda (x) (x)))
      return-three)))

(define (add-two x) (+ x 2))

(pass-if "single-value compose"
  (= 5
     ((by-cps '(lambda (x y) (x (y))))
      add-two
      return-three)))

(pass-if "identity function"
  (= 3
     ((by-cps '(lambda (x) x))
      3)))

(define if-func
  (by-cps '(lambda (x) (if x 1 2))))

(pass-if "if true"
  (= 1 (if-func #t)))

(pass-if "if false"
  (= 2 (if-func #f)))

(define *foo* 6)
(pass-if "toplevel-ref"
  (= 6
     ((by-cps '(lambda () *foo*)))))

;; (lambda () (+ 2 3))
(pass-if "+"
  (= 5
     ((cps (lambda ()
             (letval (x y) (2 3)
               (letcont (c) ((lambda (z) (call return #f (z))))
                 (call (primitive +) c (x y)))))))))
                        
