This is guile.info, produced by makeinfo version 4.13 from guile.texi.

This manual documents Guile version 2.0.9.1.

   Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2009,
2010, 2011, 2012, 2013 Free Software Foundation.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License."

INFO-DIR-SECTION The Algorithmic Language Scheme
START-INFO-DIR-ENTRY
* Guile Reference: (guile).     The Guile reference manual.
END-INFO-DIR-ENTRY


File: guile.info,  Node: Number Syntax,  Next: Integer Operations,  Prev: Exactness,  Up: Numbers

6.6.2.6 Read Syntax for Numerical Data
......................................

The read syntax for integers is a string of digits, optionally preceded
by a minus or plus character, a code indicating the base in which the
integer is encoded, and a code indicating whether the number is exact
or inexact.  The supported base codes are:

`#b'
`#B'
     the integer is written in binary (base 2)

`#o'
`#O'
     the integer is written in octal (base 8)

`#d'
`#D'
     the integer is written in decimal (base 10)

`#x'
`#X'
     the integer is written in hexadecimal (base 16)

   If the base code is omitted, the integer is assumed to be decimal.
The following examples show how these base codes are used.

     -13
     => -13

     #d-13
     => -13

     #x-13
     => -19

     #b+1101
     => 13

     #o377
     => 255

   The codes for indicating exactness (which can, incidentally, be
applied to all numerical values) are:

`#e'
`#E'
     the number is exact

`#i'
`#I'
     the number is inexact.

   If the exactness indicator is omitted, the number is exact unless it
contains a radix point.  Since Guile can not represent exact complex
numbers, an error is signalled when asking for them.

     (exact? 1.2)
     => #f

     (exact? #e1.2)
     => #t

     (exact? #e+1i)
     ERROR: Wrong type argument

   Guile also understands the syntax `+inf.0' and `-inf.0' for plus and
minus infinity, respectively.  The value must be written exactly as
shown, that is, they always must have a sign and exactly one zero digit
after the decimal point.  It also understands `+nan.0' and `-nan.0' for
the special `not-a-number' value.  The sign is ignored for
`not-a-number' and the value is always printed as `+nan.0'.


File: guile.info,  Node: Integer Operations,  Next: Comparison,  Prev: Number Syntax,  Up: Numbers

6.6.2.7 Operations on Integer Values
....................................

 -- Scheme Procedure: odd? n
 -- C Function: scm_odd_p (n)
     Return `#t' if N is an odd number, `#f' otherwise.

 -- Scheme Procedure: even? n
 -- C Function: scm_even_p (n)
     Return `#t' if N is an even number, `#f' otherwise.

 -- Scheme Procedure: quotient n d
 -- Scheme Procedure: remainder n d
 -- C Function: scm_quotient (n, d)
 -- C Function: scm_remainder (n, d)
     Return the quotient or remainder from N divided by D.  The
     quotient is rounded towards zero, and the remainder will have the
     same sign as N.  In all cases quotient and remainder satisfy N =
     Q*D + R.

          (remainder 13 4) => 1
          (remainder -13 4) => -1

     See also `truncate-quotient', `truncate-remainder' and related
     operations in *note Arithmetic::.

 -- Scheme Procedure: modulo n d
 -- C Function: scm_modulo (n, d)
     Return the remainder from N divided by D, with the same sign as D.

          (modulo 13 4) => 1
          (modulo -13 4) => 3
          (modulo 13 -4) => -3
          (modulo -13 -4) => -1

     See also `floor-quotient', `floor-remainder' and related
     operations in *note Arithmetic::.

 -- Scheme Procedure: gcd x...
 -- C Function: scm_gcd (x, y)
     Return the greatest common divisor of all arguments.  If called
     without arguments, 0 is returned.

     The C function `scm_gcd' always takes two arguments, while the
     Scheme function can take an arbitrary number.

 -- Scheme Procedure: lcm x...
 -- C Function: scm_lcm (x, y)
     Return the least common multiple of the arguments.  If called
     without arguments, 1 is returned.

     The C function `scm_lcm' always takes two arguments, while the
     Scheme function can take an arbitrary number.

 -- Scheme Procedure: modulo-expt n k m
 -- C Function: scm_modulo_expt (n, k, m)
     Return N raised to the integer exponent K, modulo M.

          (modulo-expt 2 3 5)
             => 3

 -- Scheme Procedure:  exact-integer-sqrt K
 -- C Function: void scm_exact_integer_sqrt (SCM K, SCM *S, SCM *R)
     Return two exact non-negative integers S and R such that K = S^2 +
     R and S^2 <= K < (S + 1)^2.  An error is raised if K is not an
     exact non-negative integer.

          (exact-integer-sqrt 10) => 3 and 1


File: guile.info,  Node: Comparison,  Next: Conversion,  Prev: Integer Operations,  Up: Numbers

6.6.2.8 Comparison Predicates
.............................

The C comparison functions below always takes two arguments, while the
Scheme functions can take an arbitrary number.  Also keep in mind that
the C functions return one of the Scheme boolean values `SCM_BOOL_T' or
`SCM_BOOL_F' which are both true as far as C is concerned.  Thus,
always write `scm_is_true (scm_num_eq_p (x, y))' when testing the two
Scheme numbers `x' and `y' for equality, for example.

 -- Scheme Procedure: =
 -- C Function: scm_num_eq_p (x, y)
     Return `#t' if all parameters are numerically equal.

 -- Scheme Procedure: <
 -- C Function: scm_less_p (x, y)
     Return `#t' if the list of parameters is monotonically increasing.

 -- Scheme Procedure: >
 -- C Function: scm_gr_p (x, y)
     Return `#t' if the list of parameters is monotonically decreasing.

 -- Scheme Procedure: <=
 -- C Function: scm_leq_p (x, y)
     Return `#t' if the list of parameters is monotonically
     non-decreasing.

 -- Scheme Procedure: >=
 -- C Function: scm_geq_p (x, y)
     Return `#t' if the list of parameters is monotonically
     non-increasing.

 -- Scheme Procedure: zero? z
 -- C Function: scm_zero_p (z)
     Return `#t' if Z is an exact or inexact number equal to zero.

 -- Scheme Procedure: positive? x
 -- C Function: scm_positive_p (x)
     Return `#t' if X is an exact or inexact number greater than zero.

 -- Scheme Procedure: negative? x
 -- C Function: scm_negative_p (x)
     Return `#t' if X is an exact or inexact number less than zero.


File: guile.info,  Node: Conversion,  Next: Complex,  Prev: Comparison,  Up: Numbers

6.6.2.9 Converting Numbers To and From Strings
..............................................

The following procedures read and write numbers according to their
external representation as defined by R5RS (*note R5RS Lexical
Structure: (r5rs)Lexical structure.).  *Note the `(ice-9 i18n)' module:
Number Input and Output, for locale-dependent number parsing.

 -- Scheme Procedure: number->string n [radix]
 -- C Function: scm_number_to_string (n, radix)
     Return a string holding the external representation of the number
     N in the given RADIX.  If N is inexact, a radix of 10 will be used.

 -- Scheme Procedure: string->number string [radix]
 -- C Function: scm_string_to_number (string, radix)
     Return a number of the maximally precise representation expressed
     by the given STRING. RADIX must be an exact integer, either 2, 8,
     10, or 16. If supplied, RADIX is a default radix that may be
     overridden by an explicit radix prefix in STRING (e.g. "#o177").
     If RADIX is not supplied, then the default radix is 10. If string
     is not a syntactically valid notation for a number, then
     `string->number' returns `#f'.

 -- C Function: SCM scm_c_locale_stringn_to_number (const char *string,
          size_t len, unsigned radix)
     As per `string->number' above, but taking a C string, as pointer
     and length.  The string characters should be in the current locale
     encoding (`locale' in the name refers only to that, there's no
     locale-dependent parsing).


File: guile.info,  Node: Complex,  Next: Arithmetic,  Prev: Conversion,  Up: Numbers

6.6.2.10 Complex Number Operations
..................................

 -- Scheme Procedure: make-rectangular real_part imaginary_part
 -- C Function: scm_make_rectangular (real_part, imaginary_part)
     Return a complex number constructed of the given REAL-PART and
     IMAGINARY-PART parts.

 -- Scheme Procedure: make-polar mag ang
 -- C Function: scm_make_polar (mag, ang)
     Return the complex number MAG * e^(i * ANG).

 -- Scheme Procedure: real-part z
 -- C Function: scm_real_part (z)
     Return the real part of the number Z.

 -- Scheme Procedure: imag-part z
 -- C Function: scm_imag_part (z)
     Return the imaginary part of the number Z.

 -- Scheme Procedure: magnitude z
 -- C Function: scm_magnitude (z)
     Return the magnitude of the number Z. This is the same as `abs'
     for real arguments, but also allows complex numbers.

 -- Scheme Procedure: angle z
 -- C Function: scm_angle (z)
     Return the angle of the complex number Z.

 -- C Function: SCM scm_c_make_rectangular (double re, double im)
 -- C Function: SCM scm_c_make_polar (double x, double y)
     Like `scm_make_rectangular' or `scm_make_polar', respectively, but
     these functions take `double's as their arguments.

 -- C Function: double scm_c_real_part (z)
 -- C Function: double scm_c_imag_part (z)
     Returns the real or imaginary part of Z as a `double'.

 -- C Function: double scm_c_magnitude (z)
 -- C Function: double scm_c_angle (z)
     Returns the magnitude or angle of Z as a `double'.


File: guile.info,  Node: Arithmetic,  Next: Scientific,  Prev: Complex,  Up: Numbers

6.6.2.11 Arithmetic Functions
.............................

The C arithmetic functions below always takes two arguments, while the
Scheme functions can take an arbitrary number.  When you need to invoke
them with just one argument, for example to compute the equivalent of
`(- x)', pass `SCM_UNDEFINED' as the second one: `scm_difference (x,
SCM_UNDEFINED)'.

 -- Scheme Procedure: + z1 ...
 -- C Function: scm_sum (z1, z2)
     Return the sum of all parameter values.  Return 0 if called
     without any parameters.

 -- Scheme Procedure: - z1 z2 ...
 -- C Function: scm_difference (z1, z2)
     If called with one argument Z1, -Z1 is returned. Otherwise the sum
     of all but the first argument are subtracted from the first
     argument.

 -- Scheme Procedure: * z1 ...
 -- C Function: scm_product (z1, z2)
     Return the product of all arguments.  If called without arguments,
     1 is returned.

 -- Scheme Procedure: / z1 z2 ...
 -- C Function: scm_divide (z1, z2)
     Divide the first argument by the product of the remaining
     arguments.  If called with one argument Z1, 1/Z1 is returned.

 -- Scheme Procedure: 1+ z
 -- C Function: scm_oneplus (z)
     Return Z + 1.

 -- Scheme Procedure: 1- z
 -- C function: scm_oneminus (z)
     Return Z - 1.

 -- Scheme Procedure: abs x
 -- C Function: scm_abs (x)
     Return the absolute value of X.

     X must be a number with zero imaginary part.  To calculate the
     magnitude of a complex number, use `magnitude' instead.

 -- Scheme Procedure: max x1 x2 ...
 -- C Function: scm_max (x1, x2)
     Return the maximum of all parameter values.

 -- Scheme Procedure: min x1 x2 ...
 -- C Function: scm_min (x1, x2)
     Return the minimum of all parameter values.

 -- Scheme Procedure: truncate x
 -- C Function: scm_truncate_number (x)
     Round the inexact number X towards zero.

 -- Scheme Procedure: round x
 -- C Function: scm_round_number (x)
     Round the inexact number X to the nearest integer.  When exactly
     halfway between two integers, round to the even one.

 -- Scheme Procedure: floor x
 -- C Function: scm_floor (x)
     Round the number X towards minus infinity.

 -- Scheme Procedure: ceiling x
 -- C Function: scm_ceiling (x)
     Round the number X towards infinity.

 -- C Function: double scm_c_truncate (double x)
 -- C Function: double scm_c_round (double x)
     Like `scm_truncate_number' or `scm_round_number', respectively,
     but these functions take and return `double' values.

 -- Scheme Procedure:  euclidean/ X Y
 -- Scheme Procedure:  euclidean-quotient X Y
 -- Scheme Procedure:  euclidean-remainder X Y
 -- C Function: void scm_euclidean_divide (SCM X, SCM Y, SCM *Q, SCM *R)
 -- C Function: SCM scm_euclidean_quotient (SCM X, SCM Y)
 -- C Function: SCM scm_euclidean_remainder (SCM X, SCM Y)
     These procedures accept two real numbers X and Y, where the
     divisor Y must be non-zero.  `euclidean-quotient' returns the
     integer Q and `euclidean-remainder' returns the real number R such
     that X = Q*Y + R and 0 <= R < |Y|.  `euclidean/' returns both Q and
     R, and is more efficient than computing each separately.  Note
     that when Y > 0, `euclidean-quotient' returns floor(X/Y),
     otherwise it returns ceiling(X/Y).

     Note that these operators are equivalent to the R6RS operators
     `div', `mod', and `div-and-mod'.

          (euclidean-quotient 123 10) => 12
          (euclidean-remainder 123 10) => 3
          (euclidean/ 123 10) => 12 and 3
          (euclidean/ 123 -10) => -12 and 3
          (euclidean/ -123 10) => -13 and 7
          (euclidean/ -123 -10) => 13 and 7
          (euclidean/ -123.2 -63.5) => 2.0 and 3.8
          (euclidean/ 16/3 -10/7) => -3 and 22/21

 -- Scheme Procedure:  floor/ X Y
 -- Scheme Procedure:  floor-quotient X Y
 -- Scheme Procedure:  floor-remainder X Y
 -- C Function: void scm_floor_divide (SCM X, SCM Y, SCM *Q, SCM *R)
 -- C Function: SCM scm_floor_quotient (X, Y)
 -- C Function: SCM scm_floor_remainder (X, Y)
     These procedures accept two real numbers X and Y, where the
     divisor Y must be non-zero.  `floor-quotient' returns the integer
     Q and `floor-remainder' returns the real number R such that Q =
     floor(X/Y) and X = Q*Y + R.  `floor/' returns both Q and R, and is
     more efficient than computing each separately.  Note that R, if
     non-zero, will have the same sign as Y.

     When X and Y are integers, `floor-remainder' is equivalent to the
     R5RS integer-only operator `modulo'.

          (floor-quotient 123 10) => 12
          (floor-remainder 123 10) => 3
          (floor/ 123 10) => 12 and 3
          (floor/ 123 -10) => -13 and -7
          (floor/ -123 10) => -13 and 7
          (floor/ -123 -10) => 12 and -3
          (floor/ -123.2 -63.5) => 1.0 and -59.7
          (floor/ 16/3 -10/7) => -4 and -8/21

 -- Scheme Procedure:  ceiling/ X Y
 -- Scheme Procedure:  ceiling-quotient X Y
 -- Scheme Procedure:  ceiling-remainder X Y
 -- C Function: void scm_ceiling_divide (SCM X, SCM Y, SCM *Q, SCM *R)
 -- C Function: SCM scm_ceiling_quotient (X, Y)
 -- C Function: SCM scm_ceiling_remainder (X, Y)
     These procedures accept two real numbers X and Y, where the
     divisor Y must be non-zero.  `ceiling-quotient' returns the
     integer Q and `ceiling-remainder' returns the real number R such
     that Q = ceiling(X/Y) and X = Q*Y + R.  `ceiling/' returns both Q
     and R, and is more efficient than computing each separately.  Note
     that R, if non-zero, will have the opposite sign of Y.

          (ceiling-quotient 123 10) => 13
          (ceiling-remainder 123 10) => -7
          (ceiling/ 123 10) => 13 and -7
          (ceiling/ 123 -10) => -12 and 3
          (ceiling/ -123 10) => -12 and -3
          (ceiling/ -123 -10) => 13 and 7
          (ceiling/ -123.2 -63.5) => 2.0 and 3.8
          (ceiling/ 16/3 -10/7) => -3 and 22/21

 -- Scheme Procedure:  truncate/ X Y
 -- Scheme Procedure:  truncate-quotient X Y
 -- Scheme Procedure:  truncate-remainder X Y
 -- C Function: void scm_truncate_divide (SCM X, SCM Y, SCM *Q, SCM *R)
 -- C Function: SCM scm_truncate_quotient (X, Y)
 -- C Function: SCM scm_truncate_remainder (X, Y)
     These procedures accept two real numbers X and Y, where the
     divisor Y must be non-zero.  `truncate-quotient' returns the
     integer Q and `truncate-remainder' returns the real number R such
     that Q is X/Y rounded toward zero, and X = Q*Y + R.  `truncate/'
     returns both Q and R, and is more efficient than computing each
     separately.  Note that R, if non-zero, will have the same sign as
     X.

     When X and Y are integers, these operators are equivalent to the
     R5RS integer-only operators `quotient' and `remainder'.

          (truncate-quotient 123 10) => 12
          (truncate-remainder 123 10) => 3
          (truncate/ 123 10) => 12 and 3
          (truncate/ 123 -10) => -12 and 3
          (truncate/ -123 10) => -12 and -3
          (truncate/ -123 -10) => 12 and -3
          (truncate/ -123.2 -63.5) => 1.0 and -59.7
          (truncate/ 16/3 -10/7) => -3 and 22/21

 -- Scheme Procedure:  centered/ X Y
 -- Scheme Procedure:  centered-quotient X Y
 -- Scheme Procedure:  centered-remainder X Y
 -- C Function: void scm_centered_divide (SCM X, SCM Y, SCM *Q, SCM *R)
 -- C Function: SCM scm_centered_quotient (SCM X, SCM Y)
 -- C Function: SCM scm_centered_remainder (SCM X, SCM Y)
     These procedures accept two real numbers X and Y, where the
     divisor Y must be non-zero.  `centered-quotient' returns the
     integer Q and `centered-remainder' returns the real number R such
     that X = Q*Y + R and -|Y/2| <= R < |Y/2|.  `centered/' returns
     both Q and R, and is more efficient than computing each separately.

     Note that `centered-quotient' returns X/Y rounded to the nearest
     integer.  When X/Y lies exactly half-way between two integers, the
     tie is broken according to the sign of Y.  If Y > 0, ties are
     rounded toward positive infinity, otherwise they are rounded
     toward negative infinity.  This is a consequence of the
     requirement that -|Y/2| <= R < |Y/2|.

     Note that these operators are equivalent to the R6RS operators
     `div0', `mod0', and `div0-and-mod0'.

          (centered-quotient 123 10) => 12
          (centered-remainder 123 10) => 3
          (centered/ 123 10) => 12 and 3
          (centered/ 123 -10) => -12 and 3
          (centered/ -123 10) => -12 and -3
          (centered/ -123 -10) => 12 and -3
          (centered/ 125 10) => 13 and -5
          (centered/ 127 10) => 13 and -3
          (centered/ 135 10) => 14 and -5
          (centered/ -123.2 -63.5) => 2.0 and 3.8
          (centered/ 16/3 -10/7) => -4 and -8/21

 -- Scheme Procedure:  round/ X Y
 -- Scheme Procedure:  round-quotient X Y
 -- Scheme Procedure:  round-remainder X Y
 -- C Function: void scm_round_divide (SCM X, SCM Y, SCM *Q, SCM *R)
 -- C Function: SCM scm_round_quotient (X, Y)
 -- C Function: SCM scm_round_remainder (X, Y)
     These procedures accept two real numbers X and Y, where the
     divisor Y must be non-zero.  `round-quotient' returns the integer
     Q and `round-remainder' returns the real number R such that X =
     Q*Y + R and Q is X/Y rounded to the nearest integer, with ties
     going to the nearest even integer.  `round/' returns both Q and R,
     and is more efficient than computing each separately.

     Note that `round/' and `centered/' are almost equivalent, but
     their behavior differs when X/Y lies exactly half-way between two
     integers.  In this case, `round/' chooses the nearest even
     integer, whereas `centered/' chooses in such a way to satisfy the
     constraint -|Y/2| <= R < |Y/2|, which is stronger than the
     corresponding constraint for `round/', -|Y/2| <= R <= |Y/2|.  In
     particular, when X and Y are integers, the number of possible
     remainders returned by `centered/' is |Y|, whereas the number of
     possible remainders returned by `round/' is |Y|+1 when Y is even.

          (round-quotient 123 10) => 12
          (round-remainder 123 10) => 3
          (round/ 123 10) => 12 and 3
          (round/ 123 -10) => -12 and 3
          (round/ -123 10) => -12 and -3
          (round/ -123 -10) => 12 and -3
          (round/ 125 10) => 12 and 5
          (round/ 127 10) => 13 and -3
          (round/ 135 10) => 14 and -5
          (round/ -123.2 -63.5) => 2.0 and 3.8
          (round/ 16/3 -10/7) => -4 and -8/21


File: guile.info,  Node: Scientific,  Next: Bitwise Operations,  Prev: Arithmetic,  Up: Numbers

6.6.2.12 Scientific Functions
.............................

The following procedures accept any kind of number as arguments,
including complex numbers.

 -- Scheme Procedure: sqrt z
     Return the square root of Z.  Of the two possible roots (positive
     and negative), the one with a positive real part is returned, or
     if that's zero then a positive imaginary part.  Thus,

          (sqrt 9.0)       => 3.0
          (sqrt -9.0)      => 0.0+3.0i
          (sqrt 1.0+1.0i)  => 1.09868411346781+0.455089860562227i
          (sqrt -1.0-1.0i) => 0.455089860562227-1.09868411346781i

 -- Scheme Procedure: expt z1 z2
     Return Z1 raised to the power of Z2.

 -- Scheme Procedure: sin z
     Return the sine of Z.

 -- Scheme Procedure: cos z
     Return the cosine of Z.

 -- Scheme Procedure: tan z
     Return the tangent of Z.

 -- Scheme Procedure: asin z
     Return the arcsine of Z.

 -- Scheme Procedure: acos z
     Return the arccosine of Z.

 -- Scheme Procedure: atan z
 -- Scheme Procedure: atan y x
     Return the arctangent of Z, or of Y/X.

 -- Scheme Procedure: exp z
     Return e to the power of Z, where e is the base of natural
     logarithms (2.71828...).

 -- Scheme Procedure: log z
     Return the natural logarithm of Z.

 -- Scheme Procedure: log10 z
     Return the base 10 logarithm of Z.

 -- Scheme Procedure: sinh z
     Return the hyperbolic sine of Z.

 -- Scheme Procedure: cosh z
     Return the hyperbolic cosine of Z.

 -- Scheme Procedure: tanh z
     Return the hyperbolic tangent of Z.

 -- Scheme Procedure: asinh z
     Return the hyperbolic arcsine of Z.

 -- Scheme Procedure: acosh z
     Return the hyperbolic arccosine of Z.

 -- Scheme Procedure: atanh z
     Return the hyperbolic arctangent of Z.


File: guile.info,  Node: Bitwise Operations,  Next: Random,  Prev: Scientific,  Up: Numbers

6.6.2.13 Bitwise Operations
...........................

For the following bitwise functions, negative numbers are treated as
infinite precision twos-complements.  For instance -6 is bits
...111010, with infinitely many ones on the left.  It can be seen that
adding 6 (binary 110) to such a bit pattern gives all zeros.

 -- Scheme Procedure: logand n1 n2 ...
 -- C Function: scm_logand (n1, n2)
     Return the bitwise AND of the integer arguments.

          (logand) => -1
          (logand 7) => 7
          (logand #b111 #b011 #b001) => 1

 -- Scheme Procedure: logior n1 n2 ...
 -- C Function: scm_logior (n1, n2)
     Return the bitwise OR of the integer arguments.

          (logior) => 0
          (logior 7) => 7
          (logior #b000 #b001 #b011) => 3

 -- Scheme Procedure: logxor n1 n2 ...
 -- C Function: scm_loxor (n1, n2)
     Return the bitwise XOR of the integer arguments.  A bit is set in
     the result if it is set in an odd number of arguments.

          (logxor) => 0
          (logxor 7) => 7
          (logxor #b000 #b001 #b011) => 2
          (logxor #b000 #b001 #b011 #b011) => 1

 -- Scheme Procedure: lognot n
 -- C Function: scm_lognot (n)
     Return the integer which is the ones-complement of the integer
     argument, ie. each 0 bit is changed to 1 and each 1 bit to 0.

          (number->string (lognot #b10000000) 2)
             => "-10000001"
          (number->string (lognot #b0) 2)
             => "-1"

 -- Scheme Procedure: logtest j k
 -- C Function: scm_logtest (j, k)
     Test whether J and K have any 1 bits in common.  This is
     equivalent to `(not (zero? (logand j k)))', but without actually
     calculating the `logand', just testing for non-zero.

          (logtest #b0100 #b1011) => #f
          (logtest #b0100 #b0111) => #t

 -- Scheme Procedure: logbit? index j
 -- C Function: scm_logbit_p (index, j)
     Test whether bit number INDEX in J is set.  INDEX starts from 0
     for the least significant bit.

          (logbit? 0 #b1101) => #t
          (logbit? 1 #b1101) => #f
          (logbit? 2 #b1101) => #t
          (logbit? 3 #b1101) => #t
          (logbit? 4 #b1101) => #f

 -- Scheme Procedure: ash n count
 -- C Function: scm_ash (n, count)
     Return floor(n * 2^count).  N and COUNT must be exact integers.

     With N viewed as an infinite-precision twos-complement integer,
     `ash' means a left shift introducing zero bits when COUNT is
     positive, or a right shift dropping bits when COUNT is negative.
     This is an "arithmetic" shift.

          (number->string (ash #b1 3) 2)     => "1000"
          (number->string (ash #b1010 -1) 2) => "101"

          ;; -23 is bits ...11101001, -6 is bits ...111010
          (ash -23 -2) => -6

 -- Scheme Procedure: round-ash n count
 -- C Function: scm_round_ash (n, count)
     Return round(n * 2^count).  N and COUNT must be exact integers.

     With N viewed as an infinite-precision twos-complement integer,
     `round-ash' means a left shift introducing zero bits when COUNT is
     positive, or a right shift rounding to the nearest integer (with
     ties going to the nearest even integer) when COUNT is negative.
     This is a rounded "arithmetic" shift.

          (number->string (round-ash #b1 3) 2)     => \"1000\"
          (number->string (round-ash #b1010 -1) 2) => \"101\"
          (number->string (round-ash #b1010 -2) 2) => \"10\"
          (number->string (round-ash #b1011 -2) 2) => \"11\"
          (number->string (round-ash #b1101 -2) 2) => \"11\"
          (number->string (round-ash #b1110 -2) 2) => \"100\"

 -- Scheme Procedure: logcount n
 -- C Function: scm_logcount (n)
     Return the number of bits in integer N.  If N is positive, the
     1-bits in its binary representation are counted.  If negative, the
     0-bits in its two's-complement binary representation are counted.
     If zero, 0 is returned.

          (logcount #b10101010)
             => 4
          (logcount 0)
             => 0
          (logcount -2)
             => 1

 -- Scheme Procedure: integer-length n
 -- C Function: scm_integer_length (n)
     Return the number of bits necessary to represent N.

     For positive N this is how many bits to the most significant one
     bit.  For negative N it's how many bits to the most significant
     zero bit in twos complement form.

          (integer-length #b10101010) => 8
          (integer-length #b1111)     => 4
          (integer-length 0)          => 0
          (integer-length -1)         => 0
          (integer-length -256)       => 8
          (integer-length -257)       => 9

 -- Scheme Procedure: integer-expt n k
 -- C Function: scm_integer_expt (n, k)
     Return N raised to the power K.  K must be an exact integer, N can
     be any number.

     Negative K is supported, and results in 1/n^abs(k) in the usual
     way.  N^0 is 1, as usual, and that includes 0^0 is 1.

          (integer-expt 2 5)   => 32
          (integer-expt -3 3)  => -27
          (integer-expt 5 -3)  => 1/125
          (integer-expt 0 0)   => 1

 -- Scheme Procedure: bit-extract n start end
 -- C Function: scm_bit_extract (n, start, end)
     Return the integer composed of the START (inclusive) through END
     (exclusive) bits of N.  The STARTth bit becomes the 0-th bit in
     the result.

          (number->string (bit-extract #b1101101010 0 4) 2)
             => "1010"
          (number->string (bit-extract #b1101101010 4 9) 2)
             => "10110"


File: guile.info,  Node: Random,  Prev: Bitwise Operations,  Up: Numbers

6.6.2.14 Random Number Generation
.................................

Pseudo-random numbers are generated from a random state object, which
can be created with `seed->random-state' or `datum->random-state'.  An
external representation (i.e. one which can written with `write' and
read with `read') of a random state object can be obtained via
`random-state->datum'.  The STATE parameter to the various functions
below is optional, it defaults to the state object in the
`*random-state*' variable.

 -- Scheme Procedure: copy-random-state [state]
 -- C Function: scm_copy_random_state (state)
     Return a copy of the random state STATE.

 -- Scheme Procedure: random n [state]
 -- C Function: scm_random (n, state)
     Return a number in [0, N).

     Accepts a positive integer or real n and returns a number of the
     same type between zero (inclusive) and N (exclusive). The values
     returned have a uniform distribution.

 -- Scheme Procedure: random:exp [state]
 -- C Function: scm_random_exp (state)
     Return an inexact real in an exponential distribution with mean 1.
     For an exponential distribution with mean U use `(* U
     (random:exp))'.

 -- Scheme Procedure: random:hollow-sphere! vect [state]
 -- C Function: scm_random_hollow_sphere_x (vect, state)
     Fills VECT with inexact real random numbers the sum of whose
     squares is equal to 1.0.  Thinking of VECT as coordinates in space
     of dimension N = `(vector-length VECT)', the coordinates are
     uniformly distributed over the surface of the unit n-sphere.

 -- Scheme Procedure: random:normal [state]
 -- C Function: scm_random_normal (state)
     Return an inexact real in a normal distribution.  The distribution
     used has mean 0 and standard deviation 1.  For a normal
     distribution with mean M and standard deviation D use `(+ M (* D
     (random:normal)))'.

 -- Scheme Procedure: random:normal-vector! vect [state]
 -- C Function: scm_random_normal_vector_x (vect, state)
     Fills VECT with inexact real random numbers that are independent
     and standard normally distributed (i.e., with mean 0 and variance
     1).

 -- Scheme Procedure: random:solid-sphere! vect [state]
 -- C Function: scm_random_solid_sphere_x (vect, state)
     Fills VECT with inexact real random numbers the sum of whose
     squares is less than 1.0.  Thinking of VECT as coordinates in
     space of dimension N = `(vector-length VECT)', the coordinates are
     uniformly distributed within the unit N-sphere.

 -- Scheme Procedure: random:uniform [state]
 -- C Function: scm_random_uniform (state)
     Return a uniformly distributed inexact real random number in [0,1).

 -- Scheme Procedure: seed->random-state seed
 -- C Function: scm_seed_to_random_state (seed)
     Return a new random state using SEED.

 -- Scheme Procedure: datum->random-state datum
 -- C Function: scm_datum_to_random_state (datum)
     Return a new random state from DATUM, which should have been
     obtained by `random-state->datum'.

 -- Scheme Procedure: random-state->datum state
 -- C Function: scm_random_state_to_datum (state)
     Return a datum representation of STATE that may be written out and
     read back with the Scheme reader.

 -- Scheme Procedure: random-state-from-platform
 -- C Function: scm_random_state_from_platform ()
     Construct a new random state seeded from a platform-specific
     source of entropy, appropriate for use in non-security-critical
     applications.  Currently `/dev/urandom' is tried first, or else
     the seed is based on the time, date, process ID, an address from a
     freshly allocated heap cell, an address from the local stack
     frame, and a high-resolution timer if available.

 -- Variable: *random-state*
     The global random state used by the above functions when the STATE
     parameter is not given.

   Note that the initial value of `*random-state*' is the same every
time Guile starts up.  Therefore, if you don't pass a STATE parameter
to the above procedures, and you don't set `*random-state*' to
`(seed->random-state your-seed)', where `your-seed' is something that
_isn't_ the same every time, you'll get the same sequence of "random"
numbers on every run.

   For example, unless the relevant source code has changed, `(map
random (cdr (iota 30)))', if the first use of random numbers since
Guile started up, will always give:

     (map random (cdr (iota 19)))
     =>
     (0 1 1 2 2 2 1 2 6 7 10 0 5 3 12 5 5 12)

   To seed the random state in a sensible way for non-security-critical
applications, do this during initialization of your program:

     (set! *random-state* (random-state-from-platform))


File: guile.info,  Node: Characters,  Next: Character Sets,  Prev: Numbers,  Up: Simple Data Types

6.6.3 Characters
----------------

In Scheme, there is a data type to describe a single character.

   Defining what exactly a character _is_ can be more complicated than
it seems.  Guile follows the advice of R6RS and uses The Unicode
Standard to help define what a character is.  So, for Guile, a
character is anything in the Unicode Character Database.

   The Unicode Character Database is basically a table of characters
indexed using integers called 'code points'.  Valid code points are in
the ranges 0 to `#xD7FF' inclusive or `#xE000' to `#x10FFFF' inclusive,
which is about 1.1 million code points.

   Any code point that has been assigned to a character or that has
otherwise been given a meaning by Unicode is called a 'designated code
point'.  Most of the designated code points, about 200,000 of them,
indicate characters, accents or other combining marks that modify other
characters, symbols, whitespace, and control characters.  Some are not
characters but indicators that suggest how to format or display
neighboring characters.

   If a code point is not a designated code point - if it has not been
assigned to a character by The Unicode Standard - it is a 'reserved
code point', meaning that they are reserved for future use.  Most of
the code points, about 800,000, are 'reserved code points'.

   By convention, a Unicode code point is written as "U+XXXX" where
"XXXX" is a hexadecimal number.  Please note that this convenient
notation is not valid code.  Guile does not interpret "U+XXXX" as a
character.

   In Scheme, a character literal is written as `#\NAME' where NAME is
the name of the character that you want.  Printable characters have
their usual single character name; for example, `#\a' is a lower case
`a'.

   Some of the code points are 'combining characters' that are not meant
to be printed by themselves but are instead meant to modify the
appearance of the previous character.  For combining characters, an
alternate form of the character literal is `#\' followed by U+25CC (a
small, dotted circle), followed by the combining character.  This
allows the combining character to be drawn on the circle, not on the
backslash of `#\'.

   Many of the non-printing characters, such as whitespace characters
and control characters, also have names.

   The most commonly used non-printing characters have long character
names, described in the table below.

Character Name  Codepoint
`#\nul'         U+0000
`#\alarm'       u+0007
`#\backspace'   U+0008
`#\tab'         U+0009
`#\linefeed'    U+000A
`#\newline'     U+000A
`#\vtab'        U+000B
`#\page'        U+000C
`#\return'      U+000D
`#\esc'         U+001B
`#\space'       U+0020
`#\delete'      U+007F

   There are also short names for all of the "C0 control characters"
(those with code points below 32).  The following table lists the short
name for each character.

0 = `#\nul'        1 = `#\soh'        2 = `#\stx'        3 = `#\etx'
4 = `#\eot'        5 = `#\enq'        6 = `#\ack'        7 = `#\bel'
8 = `#\bs'         9 = `#\ht'         10 = `#\lf'        11 = `#\vt'
12 = `#\ff'        13 = `#\cr'        14 = `#\so'        15 = `#\si'
16 = `#\dle'       17 = `#\dc1'       18 = `#\dc2'       19 = `#\dc3'
20 = `#\dc4'       21 = `#\nak'       22 = `#\syn'       23 = `#\etb'
24 = `#\can'       25 = `#\em'        26 = `#\sub'       27 = `#\esc'
28 = `#\fs'        29 = `#\gs'        30 = `#\rs'        31 = `#\us'
32 = `#\sp'                                              

   The short name for the "delete" character (code point U+007F) is
`#\del'.

   There are also a few alternative names left over for compatibility
with previous versions of Guile.

Alternate       Standard
`#\nl'          `#\newline'
`#\np'          `#\page'
`#\null'        `#\nul'

   Characters may also be written using their code point values.  They
can be written with as an octal number, such as `#\10' for `#\bs' or
`#\177' for `#\del'.

   If one prefers hex to octal, there is an additional syntax for
character escapes: `#\xHHHH' - the letter 'x' followed by a hexadecimal
number of one to eight digits.

 -- Scheme Procedure: char? x
 -- C Function: scm_char_p (x)
     Return `#t' if X is a character, else `#f'.

   Fundamentally, the character comparison operations below are numeric
comparisons of the character's code points.

 -- Scheme Procedure: char=? x y
     Return `#t' if code point of X is equal to the code point of Y,
     else `#f'.

 -- Scheme Procedure: char<? x y
     Return `#t' if the code point of X is less than the code point of
     Y, else `#f'.

 -- Scheme Procedure: char<=? x y
     Return `#t' if the code point of X is less than or equal to the
     code point of Y, else `#f'.

 -- Scheme Procedure: char>? x y
     Return `#t' if the code point of X is greater than the code point
     of Y, else `#f'.

 -- Scheme Procedure: char>=? x y
     Return `#t' if the code point of X is greater than or equal to the
     code point of Y, else `#f'.

   Case-insensitive character comparisons use _Unicode case folding_.
In case folding comparisons, if a character is lowercase and has an
uppercase form that can be expressed as a single character, it is
converted to uppercase before comparison.  All other characters undergo
no conversion before the comparison occurs.  This includes the German
sharp S (Eszett) which is not uppercased before conversion because its
uppercase form has two characters.  Unicode case folding is language
independent: it uses rules that are generally true, but, it cannot
cover all cases for all languages.

 -- Scheme Procedure: char-ci=? x y
     Return `#t' if the case-folded code point of X is the same as the
     case-folded code point of Y, else `#f'.

 -- Scheme Procedure: char-ci<? x y
     Return `#t' if the case-folded code point of X is less than the
     case-folded code point of Y, else `#f'.

 -- Scheme Procedure: char-ci<=? x y
     Return `#t' if the case-folded code point of X is less than or
     equal to the case-folded code point of Y, else `#f'.

 -- Scheme Procedure: char-ci>? x y
     Return `#t' if the case-folded code point of X is greater than the
     case-folded code point of Y, else `#f'.

 -- Scheme Procedure: char-ci>=? x y
     Return `#t' if the case-folded code point of X is greater than or
     equal to the case-folded code point of Y, else `#f'.

 -- Scheme Procedure: char-alphabetic? chr
 -- C Function: scm_char_alphabetic_p (chr)
     Return `#t' if CHR is alphabetic, else `#f'.

 -- Scheme Procedure: char-numeric? chr
 -- C Function: scm_char_numeric_p (chr)
     Return `#t' if CHR is numeric, else `#f'.

 -- Scheme Procedure: char-whitespace? chr
 -- C Function: scm_char_whitespace_p (chr)
     Return `#t' if CHR is whitespace, else `#f'.

 -- Scheme Procedure: char-upper-case? chr
 -- C Function: scm_char_upper_case_p (chr)
     Return `#t' if CHR is uppercase, else `#f'.

 -- Scheme Procedure: char-lower-case? chr
 -- C Function: scm_char_lower_case_p (chr)
     Return `#t' if CHR is lowercase, else `#f'.

 -- Scheme Procedure: char-is-both? chr
 -- C Function: scm_char_is_both_p (chr)
     Return `#t' if CHR is either uppercase or lowercase, else `#f'.

 -- Scheme Procedure: char-general-category chr
 -- C Function: scm_char_general_category (chr)
     Return a symbol giving the two-letter name of the Unicode general
     category assigned to CHR or `#f' if no named category is assigned.
     The following table provides a list of category names along with
     their meanings.

     Lu      Uppercase letter            Pf      Final quote punctuation
     Ll      Lowercase letter            Po      Other punctuation
     Lt      Titlecase letter            Sm      Math symbol
     Lm      Modifier letter             Sc      Currency symbol
     Lo      Other letter                Sk      Modifier symbol
     Mn      Non-spacing mark            So      Other symbol
     Mc      Combining spacing mark      Zs      Space separator
     Me      Enclosing mark              Zl      Line separator
     Nd      Decimal digit number        Zp      Paragraph separator
     Nl      Letter number               Cc      Control
     No      Other number                Cf      Format
     Pc      Connector punctuation       Cs      Surrogate
     Pd      Dash punctuation            Co      Private use
     Ps      Open punctuation            Cn      Unassigned
     Pe      Close punctuation                   
     Pi      Initial quote punctuation           

 -- Scheme Procedure: char->integer chr
 -- C Function: scm_char_to_integer (chr)
     Return the code point of CHR.

 -- Scheme Procedure: integer->char n
 -- C Function: scm_integer_to_char (n)
     Return the character that has code point N.  The integer N must be
     a valid code point.  Valid code points are in the ranges 0 to
     `#xD7FF' inclusive or `#xE000' to `#x10FFFF' inclusive.

 -- Scheme Procedure: char-upcase chr
 -- C Function: scm_char_upcase (chr)
     Return the uppercase character version of CHR.

 -- Scheme Procedure: char-downcase chr
 -- C Function: scm_char_downcase (chr)
     Return the lowercase character version of CHR.

 -- Scheme Procedure: char-titlecase chr
 -- C Function: scm_char_titlecase (chr)
     Return the titlecase character version of CHR if one exists;
     otherwise return the uppercase version.

     For most characters these will be the same, but the Unicode
     Standard includes certain digraph compatibility characters, such
     as `U+01F3' "dz", for which the uppercase and titlecase characters
     are different (`U+01F1' "DZ" and `U+01F2' "Dz" in this case,
     respectively).

 -- C Function: scm_t_wchar scm_c_upcase (scm_t_wchar C)
 -- C Function: scm_t_wchar scm_c_downcase (scm_t_wchar C)
 -- C Function: scm_t_wchar scm_c_titlecase (scm_t_wchar C)
     These C functions take an integer representation of a Unicode
     codepoint and return the codepoint corresponding to its uppercase,
     lowercase, and titlecase forms respectively.  The type
     `scm_t_wchar' is a signed, 32-bit integer.


File: guile.info,  Node: Character Sets,  Next: Strings,  Prev: Characters,  Up: Simple Data Types

6.6.4 Character Sets
--------------------

The features described in this section correspond directly to SRFI-14.

   The data type "charset" implements sets of characters (*note
Characters::).  Because the internal representation of character sets
is not visible to the user, a lot of procedures for handling them are
provided.

   Character sets can be created, extended, tested for the membership
of a characters and be compared to other character sets.

* Menu:

* Character Set Predicates/Comparison::
* Iterating Over Character Sets::  Enumerate charset elements.
* Creating Character Sets::        Making new charsets.
* Querying Character Sets::        Test charsets for membership etc.
* Character-Set Algebra::          Calculating new charsets.
* Standard Character Sets::        Variables containing predefined charsets.


File: guile.info,  Node: Character Set Predicates/Comparison,  Next: Iterating Over Character Sets,  Up: Character Sets

6.6.4.1 Character Set Predicates/Comparison
...........................................

Use these procedures for testing whether an object is a character set,
or whether several character sets are equal or subsets of each other.
`char-set-hash' can be used for calculating a hash value, maybe for
usage in fast lookup procedures.

 -- Scheme Procedure: char-set? obj
 -- C Function: scm_char_set_p (obj)
     Return `#t' if OBJ is a character set, `#f' otherwise.

 -- Scheme Procedure: char-set= char_set ...
 -- C Function: scm_char_set_eq (char_sets)
     Return `#t' if all given character sets are equal.

 -- Scheme Procedure: char-set<= char_set ...
 -- C Function: scm_char_set_leq (char_sets)
     Return `#t' if every character set CHAR_SETi is a subset of
     character set CHAR_SETi+1.

 -- Scheme Procedure: char-set-hash cs [bound]
 -- C Function: scm_char_set_hash (cs, bound)
     Compute a hash value for the character set CS.  If BOUND is given
     and non-zero, it restricts the returned value to the range 0 ...
     BOUND - 1.


File: guile.info,  Node: Iterating Over Character Sets,  Next: Creating Character Sets,  Prev: Character Set Predicates/Comparison,  Up: Character Sets

6.6.4.2 Iterating Over Character Sets
.....................................

Character set cursors are a means for iterating over the members of a
character sets.  After creating a character set cursor with
`char-set-cursor', a cursor can be dereferenced with `char-set-ref',
advanced to the next member with `char-set-cursor-next'.  Whether a
cursor has passed past the last element of the set can be checked with
`end-of-char-set?'.

   Additionally, mapping and (un-)folding procedures for character sets
are provided.

 -- Scheme Procedure: char-set-cursor cs
 -- C Function: scm_char_set_cursor (cs)
     Return a cursor into the character set CS.

 -- Scheme Procedure: char-set-ref cs cursor
 -- C Function: scm_char_set_ref (cs, cursor)
     Return the character at the current cursor position CURSOR in the
     character set CS.  It is an error to pass a cursor for which
     `end-of-char-set?' returns true.

 -- Scheme Procedure: char-set-cursor-next cs cursor
 -- C Function: scm_char_set_cursor_next (cs, cursor)
     Advance the character set cursor CURSOR to the next character in
     the character set CS.  It is an error if the cursor given
     satisfies `end-of-char-set?'.

 -- Scheme Procedure: end-of-char-set? cursor
 -- C Function: scm_end_of_char_set_p (cursor)
     Return `#t' if CURSOR has reached the end of a character set, `#f'
     otherwise.

 -- Scheme Procedure: char-set-fold kons knil cs
 -- C Function: scm_char_set_fold (kons, knil, cs)
     Fold the procedure KONS over the character set CS, initializing it
     with KNIL.

 -- Scheme Procedure: char-set-unfold p f g seed [base_cs]
 -- C Function: scm_char_set_unfold (p, f, g, seed, base_cs)
     This is a fundamental constructor for character sets.
        * G is used to generate a series of "seed" values from the
          initial seed: SEED, (G SEED), (G^2 SEED), (G^3 SEED), ...

        * P tells us when to stop - when it returns true when applied
          to one of the seed values.

        * F maps each seed value to a character. These characters are
          added to the base character set BASE_CS to form the result;
          BASE_CS defaults to the empty set.

 -- Scheme Procedure: char-set-unfold! p f g seed base_cs
 -- C Function: scm_char_set_unfold_x (p, f, g, seed, base_cs)
     This is a fundamental constructor for character sets.
        * G is used to generate a series of "seed" values from the
          initial seed: SEED, (G SEED), (G^2 SEED), (G^3 SEED), ...

        * P tells us when to stop - when it returns true when applied
          to one of the seed values.

        * F maps each seed value to a character. These characters are
          added to the base character set BASE_CS to form the result;
          BASE_CS defaults to the empty set.

 -- Scheme Procedure: char-set-for-each proc cs
 -- C Function: scm_char_set_for_each (proc, cs)
     Apply PROC to every character in the character set CS.  The return
     value is not specified.

 -- Scheme Procedure: char-set-map proc cs
 -- C Function: scm_char_set_map (proc, cs)
     Map the procedure PROC over every character in CS.  PROC must be a
     character -> character procedure.


File: guile.info,  Node: Creating Character Sets,  Next: Querying Character Sets,  Prev: Iterating Over Character Sets,  Up: Character Sets

6.6.4.3 Creating Character Sets
...............................

New character sets are produced with these procedures.

 -- Scheme Procedure: char-set-copy cs
 -- C Function: scm_char_set_copy (cs)
     Return a newly allocated character set containing all characters
     in CS.

 -- Scheme Procedure: char-set chr ...
 -- C Function: scm_char_set (chrs)
     Return a character set containing all given characters.

 -- Scheme Procedure: list->char-set list [base_cs]
 -- C Function: scm_list_to_char_set (list, base_cs)
     Convert the character list LIST to a character set.  If the
     character set BASE_CS is given, the character in this set are also
     included in the result.

 -- Scheme Procedure: list->char-set! list base_cs
 -- C Function: scm_list_to_char_set_x (list, base_cs)
     Convert the character list LIST to a character set.  The
     characters are added to BASE_CS and BASE_CS is returned.

 -- Scheme Procedure: string->char-set str [base_cs]
 -- C Function: scm_string_to_char_set (str, base_cs)
     Convert the string STR to a character set.  If the character set
     BASE_CS is given, the characters in this set are also included in
     the result.

 -- Scheme Procedure: string->char-set! str base_cs
 -- C Function: scm_string_to_char_set_x (str, base_cs)
     Convert the string STR to a character set.  The characters from
     the string are added to BASE_CS, and BASE_CS is returned.

 -- Scheme Procedure: char-set-filter pred cs [base_cs]
 -- C Function: scm_char_set_filter (pred, cs, base_cs)
     Return a character set containing every character from CS so that
     it satisfies PRED.  If provided, the characters from BASE_CS are
     added to the result.

 -- Scheme Procedure: char-set-filter! pred cs base_cs
 -- C Function: scm_char_set_filter_x (pred, cs, base_cs)
     Return a character set containing every character from CS so that
     it satisfies PRED.  The characters are added to BASE_CS and
     BASE_CS is returned.

 -- Scheme Procedure: ucs-range->char-set lower upper [error [base_cs]]
 -- C Function: scm_ucs_range_to_char_set (lower, upper, error, base_cs)
     Return a character set containing all characters whose character
     codes lie in the half-open range [LOWER,UPPER).

     If ERROR is a true value, an error is signalled if the specified
     range contains characters which are not contained in the
     implemented character range.  If ERROR is `#f', these characters
     are silently left out of the resulting character set.

     The characters in BASE_CS are added to the result, if given.

 -- Scheme Procedure: ucs-range->char-set! lower upper error base_cs
 -- C Function: scm_ucs_range_to_char_set_x (lower, upper, error,
          base_cs)
     Return a character set containing all characters whose character
     codes lie in the half-open range [LOWER,UPPER).

     If ERROR is a true value, an error is signalled if the specified
     range contains characters which are not contained in the
     implemented character range.  If ERROR is `#f', these characters
     are silently left out of the resulting character set.

     The characters are added to BASE_CS and BASE_CS is returned.

 -- Scheme Procedure: ->char-set x
 -- C Function: scm_to_char_set (x)
     Coerces x into a char-set. X may be a string, character or
     char-set. A string is converted to the set of its constituent
     characters; a character is converted to a singleton set; a
     char-set is returned as-is.


File: guile.info,  Node: Querying Character Sets,  Next: Character-Set Algebra,  Prev: Creating Character Sets,  Up: Character Sets

6.6.4.4 Querying Character Sets
...............................

Access the elements and other information of a character set with these
procedures.

 -- Scheme Procedure: %char-set-dump cs
     Returns an association list containing debugging information for
     CS. The association list has the following entries.
    `char-set'
          The char-set itself

    `len'
          The number of groups of contiguous code points the char-set
          contains

    `ranges'
          A list of lists where each sublist is a range of code points
          and their associated characters
     The return value of this function cannot be relied upon to be
     consistent between versions of Guile and should not be used in
     code.

 -- Scheme Procedure: char-set-size cs
 -- C Function: scm_char_set_size (cs)
     Return the number of elements in character set CS.

 -- Scheme Procedure: char-set-count pred cs
 -- C Function: scm_char_set_count (pred, cs)
     Return the number of the elements int the character set CS which
     satisfy the predicate PRED.

 -- Scheme Procedure: char-set->list cs
 -- C Function: scm_char_set_to_list (cs)
     Return a list containing the elements of the character set CS.

 -- Scheme Procedure: char-set->string cs
 -- C Function: scm_char_set_to_string (cs)
     Return a string containing the elements of the character set CS.
     The order in which the characters are placed in the string is not
     defined.

 -- Scheme Procedure: char-set-contains? cs ch
 -- C Function: scm_char_set_contains_p (cs, ch)
     Return `#t' if the character CH is contained in the character set
     CS, or `#f' otherwise.

 -- Scheme Procedure: char-set-every pred cs
 -- C Function: scm_char_set_every (pred, cs)
     Return a true value if every character in the character set CS
     satisfies the predicate PRED.

 -- Scheme Procedure: char-set-any pred cs
 -- C Function: scm_char_set_any (pred, cs)
     Return a true value if any character in the character set CS
     satisfies the predicate PRED.


File: guile.info,  Node: Character-Set Algebra,  Next: Standard Character Sets,  Prev: Querying Character Sets,  Up: Character Sets

6.6.4.5 Character-Set Algebra
.............................

Character sets can be manipulated with the common set algebra operation,
such as union, complement, intersection etc.  All of these procedures
provide side-effecting variants, which modify their character set
argument(s).

 -- Scheme Procedure: char-set-adjoin cs chr ...
 -- C Function: scm_char_set_adjoin (cs, chrs)
     Add all character arguments to the first argument, which must be a
     character set.

 -- Scheme Procedure: char-set-delete cs chr ...
 -- C Function: scm_char_set_delete (cs, chrs)
     Delete all character arguments from the first argument, which must
     be a character set.

 -- Scheme Procedure: char-set-adjoin! cs chr ...
 -- C Function: scm_char_set_adjoin_x (cs, chrs)
     Add all character arguments to the first argument, which must be a
     character set.

 -- Scheme Procedure: char-set-delete! cs chr ...
 -- C Function: scm_char_set_delete_x (cs, chrs)
     Delete all character arguments from the first argument, which must
     be a character set.

 -- Scheme Procedure: char-set-complement cs
 -- C Function: scm_char_set_complement (cs)
     Return the complement of the character set CS.

   Note that the complement of a character set is likely to contain many
reserved code points (code points that are not associated with
characters).  It may be helpful to modify the output of
`char-set-complement' by computing its intersection with the set of
designated code points, `char-set:designated'.

 -- Scheme Procedure: char-set-union cs ...
 -- C Function: scm_char_set_union (char_sets)
     Return the union of all argument character sets.

 -- Scheme Procedure: char-set-intersection cs ...
 -- C Function: scm_char_set_intersection (char_sets)
     Return the intersection of all argument character sets.

 -- Scheme Procedure: char-set-difference cs1 cs ...
 -- C Function: scm_char_set_difference (cs1, char_sets)
     Return the difference of all argument character sets.

 -- Scheme Procedure: char-set-xor cs ...
 -- C Function: scm_char_set_xor (char_sets)
     Return the exclusive-or of all argument character sets.

 -- Scheme Procedure: char-set-diff+intersection cs1 cs ...
 -- C Function: scm_char_set_diff_plus_intersection (cs1, char_sets)
     Return the difference and the intersection of all argument
     character sets.

 -- Scheme Procedure: char-set-complement! cs
 -- C Function: scm_char_set_complement_x (cs)
     Return the complement of the character set CS.

 -- Scheme Procedure: char-set-union! cs1 cs ...
 -- C Function: scm_char_set_union_x (cs1, char_sets)
     Return the union of all argument character sets.

 -- Scheme Procedure: char-set-intersection! cs1 cs ...
 -- C Function: scm_char_set_intersection_x (cs1, char_sets)
     Return the intersection of all argument character sets.

 -- Scheme Procedure: char-set-difference! cs1 cs ...
 -- C Function: scm_char_set_difference_x (cs1, char_sets)
     Return the difference of all argument character sets.

 -- Scheme Procedure: char-set-xor! cs1 cs ...
 -- C Function: scm_char_set_xor_x (cs1, char_sets)
     Return the exclusive-or of all argument character sets.

 -- Scheme Procedure: char-set-diff+intersection! cs1 cs2 cs ...
 -- C Function: scm_char_set_diff_plus_intersection_x (cs1, cs2,
          char_sets)
     Return the difference and the intersection of all argument
     character sets.


File: guile.info,  Node: Standard Character Sets,  Prev: Character-Set Algebra,  Up: Character Sets

6.6.4.6 Standard Character Sets
...............................

In order to make the use of the character set data type and procedures
useful, several predefined character set variables exist.

   These character sets are locale independent and are not recomputed
upon a `setlocale' call.  They contain characters from the whole range
of Unicode code points. For instance, `char-set:letter' contains about
100,000 characters.

 -- Scheme Variable: char-set:lower-case
 -- C Variable: scm_char_set_lower_case
     All lower-case characters.

 -- Scheme Variable: char-set:upper-case
 -- C Variable: scm_char_set_upper_case
     All upper-case characters.

 -- Scheme Variable: char-set:title-case
 -- C Variable: scm_char_set_title_case
     All single characters that function as if they were an upper-case
     letter followed by a lower-case letter.

 -- Scheme Variable: char-set:letter
 -- C Variable: scm_char_set_letter
     All letters.  This includes `char-set:lower-case',
     `char-set:upper-case', `char-set:title-case', and many letters
     that have no case at all.  For example, Chinese and Japanese
     characters typically have no concept of case.

 -- Scheme Variable: char-set:digit
 -- C Variable: scm_char_set_digit
     All digits.

 -- Scheme Variable: char-set:letter+digit
 -- C Variable: scm_char_set_letter_and_digit
     The union of `char-set:letter' and `char-set:digit'.

 -- Scheme Variable: char-set:graphic
 -- C Variable: scm_char_set_graphic
     All characters which would put ink on the paper.

 -- Scheme Variable: char-set:printing
 -- C Variable: scm_char_set_printing
     The union of `char-set:graphic' and `char-set:whitespace'.

 -- Scheme Variable: char-set:whitespace
 -- C Variable: scm_char_set_whitespace
     All whitespace characters.

 -- Scheme Variable: char-set:blank
 -- C Variable: scm_char_set_blank
     All horizontal whitespace characters, which notably includes
     `#\space' and `#\tab'.

 -- Scheme Variable: char-set:iso-control
 -- C Variable: scm_char_set_iso_control
     The ISO control characters are the C0 control characters (U+0000 to
     U+001F), delete (U+007F), and the C1 control characters (U+0080 to
     U+009F).

 -- Scheme Variable: char-set:punctuation
 -- C Variable: scm_char_set_punctuation
     All punctuation characters, such as the characters
     `!"#%&'()*,-./:;?@[\\]_{}'

 -- Scheme Variable: char-set:symbol
 -- C Variable: scm_char_set_symbol
     All symbol characters, such as the characters `$+<=>^`|~'.

 -- Scheme Variable: char-set:hex-digit
 -- C Variable: scm_char_set_hex_digit
     The hexadecimal digits `0123456789abcdefABCDEF'.

 -- Scheme Variable: char-set:ascii
 -- C Variable: scm_char_set_ascii
     All ASCII characters.

 -- Scheme Variable: char-set:empty
 -- C Variable: scm_char_set_empty
     The empty character set.

 -- Scheme Variable: char-set:designated
 -- C Variable: scm_char_set_designated
     This character set contains all designated code points.  This
     includes all the code points to which Unicode has assigned a
     character or other meaning.

 -- Scheme Variable: char-set:full
 -- C Variable: scm_char_set_full
     This character set contains all possible code points.  This
     includes both designated and reserved code points.


File: guile.info,  Node: Strings,  Next: Bytevectors,  Prev: Character Sets,  Up: Simple Data Types

6.6.5 Strings
-------------

Strings are fixed-length sequences of characters.  They can be created
by calling constructor procedures, but they can also literally get
entered at the REPL or in Scheme source files.

   Strings always carry the information about how many characters they
are composed of with them, so there is no special end-of-string
character, like in C.  That means that Scheme strings can contain any
character, even the `#\nul' character `\0'.

   To use strings efficiently, you need to know a bit about how Guile
implements them.  In Guile, a string consists of two parts, a head and
the actual memory where the characters are stored.  When a string (or a
substring of it) is copied, only a new head gets created, the memory is
usually not copied.  The two heads start out pointing to the same
memory.

   When one of these two strings is modified, as with `string-set!',
their common memory does get copied so that each string has its own
memory and modifying one does not accidentally modify the other as well.
Thus, Guile's strings are `copy on write'; the actual copying of their
memory is delayed until one string is written to.

   This implementation makes functions like `substring' very efficient
in the common case that no modifications are done to the involved
strings.

   If you do know that your strings are getting modified right away, you
can use `substring/copy' instead of `substring'.  This function
performs the copy immediately at the time of creation.  This is more
efficient, especially in a multi-threaded program.  Also,
`substring/copy' can avoid the problem that a short substring holds on
to the memory of a very large original string that could otherwise be
recycled.

   If you want to avoid the copy altogether, so that modifications of
one string show up in the other, you can use `substring/shared'.  The
strings created by this procedure are called "mutation sharing
substrings" since the substring and the original string share
modifications to each other.

   If you want to prevent modifications, use `substring/read-only'.

   Guile provides all procedures of SRFI-13 and a few more.

* Menu:

* String Syntax::                   Read syntax for strings.
* String Predicates::               Testing strings for certain properties.
* String Constructors::             Creating new string objects.
* List/String Conversion::          Converting from/to lists of characters.
* String Selection::                Select portions from strings.
* String Modification::             Modify parts or whole strings.
* String Comparison::               Lexicographic ordering predicates.
* String Searching::                Searching in strings.
* Alphabetic Case Mapping::         Convert the alphabetic case of strings.
* Reversing and Appending Strings:: Appending strings to form a new string.
* Mapping Folding and Unfolding::   Iterating over strings.
* Miscellaneous String Operations:: Replicating, insertion, parsing, ...
* Representing Strings as Bytes::   Encoding and decoding strings.
* Conversion to/from C::
* String Internals::                The storage strategy for strings.


File: guile.info,  Node: String Syntax,  Next: String Predicates,  Up: Strings

6.6.5.1 String Read Syntax
..........................

The read syntax for strings is an arbitrarily long sequence of
characters enclosed in double quotes (").

   Backslash is an escape character and can be used to insert the
following special characters.  \" and \\ are R5RS standard, the next
seven are R6RS standard -- notice they follow C syntax -- and the
remaining four are Guile extensions.

\\
     Backslash character.

\"
     Double quote character (an unescaped " is otherwise the end of the
     string).

\a
     Bell character (ASCII 7).

\f
     Formfeed character (ASCII 12).

\n
     Newline character (ASCII 10).

\r
     Carriage return character (ASCII 13).

\t
     Tab character (ASCII 9).

\v
     Vertical tab character (ASCII 11).

\b
     Backspace character (ASCII 8).

\0
     NUL character (ASCII 0).

\ followed by newline (ASCII 10)
     Nothing.  This way if \ is the last character in a line, the
     string will continue with the first character from the next line,
     without a line break.

     If the `hungry-eol-escapes' reader option is enabled, which is not
     the case by default, leading whitespace on the next line is
     discarded.

          "foo\
            bar"
          => "foo  bar"
          (read-enable 'hungry-eol-escapes)
          "foo\
            bar"
          => "foobar"

\xHH
     Character code given by two hexadecimal digits.  For example \x7f
     for an ASCII DEL (127).

\uHHHH
     Character code given by four hexadecimal digits.  For example
     \u0100 for a capital A with macron (U+0100).

\UHHHHHH
     Character code given by six hexadecimal digits.  For example
     \U010402.

The following are examples of string literals:

     "foo"
     "bar plonk"
     "Hello World"
     "\"Hi\", he said."

   The three escape sequences `\xHH', `\uHHHH' and `\UHHHHHH' were
chosen to not break compatibility with code written for previous
versions of Guile.  The R6RS specification suggests a different,
incompatible syntax for hex escapes: `\xHHHH;' - a character code
followed by one to eight hexadecimal digits terminated with a
semicolon.  If this escape format is desired instead, it can be enabled
with the reader option `r6rs-hex-escapes'.

     (read-enable 'r6rs-hex-escapes)

   For more on reader options, *Note Scheme Read::.


File: guile.info,  Node: String Predicates,  Next: String Constructors,  Prev: String Syntax,  Up: Strings

6.6.5.2 String Predicates
.........................

The following procedures can be used to check whether a given string
fulfills some specified property.

 -- Scheme Procedure: string? obj
 -- C Function: scm_string_p (obj)
     Return `#t' if OBJ is a string, else `#f'.

 -- C Function: int scm_is_string (SCM obj)
     Returns `1' if OBJ is a string, `0' otherwise.

 -- Scheme Procedure: string-null? str
 -- C Function: scm_string_null_p (str)
     Return `#t' if STR's length is zero, and `#f' otherwise.
          (string-null? "")  => #t
          y                    => "foo"
          (string-null? y)     => #f

 -- Scheme Procedure: string-any char_pred s [start [end]]
 -- C Function: scm_string_any (char_pred, s, start, end)
     Check if CHAR_PRED is true for any character in string S.

     CHAR_PRED can be a character to check for any equal to that, or a
     character set (*note Character Sets::) to check for any in that
     set, or a predicate procedure to call.

     For a procedure, calls `(CHAR_PRED c)' are made successively on
     the characters from START to END.  If CHAR_PRED returns true (ie.
     non-`#f'), `string-any' stops and that return value is the return
     from `string-any'.  The call on the last character (ie. at END-1),
     if that point is reached, is a tail call.

     If there are no characters in S (ie. START equals END) then the
     return is `#f'.

 -- Scheme Procedure: string-every char_pred s [start [end]]
 -- C Function: scm_string_every (char_pred, s, start, end)
     Check if CHAR_PRED is true for every character in string S.

     CHAR_PRED can be a character to check for every character equal to
     that, or a character set (*note Character Sets::) to check for
     every character being in that set, or a predicate procedure to
     call.

     For a procedure, calls `(CHAR_PRED c)' are made successively on
     the characters from START to END.  If CHAR_PRED returns `#f',
     `string-every' stops and returns `#f'.  The call on the last
     character (ie. at END-1), if that point is reached, is a tail call
     and the return from that call is the return from `string-every'.

     If there are no characters in S (ie. START equals END) then the
     return is `#t'.


File: guile.info,  Node: String Constructors,  Next: List/String Conversion,  Prev: String Predicates,  Up: Strings

6.6.5.3 String Constructors
...........................

The string constructor procedures create new string objects, possibly
initializing them with some specified character data.  See also *Note
String Selection::, for ways to create strings from existing strings.

 -- Scheme Procedure: string char...
     Return a newly allocated string made from the given character
     arguments.

          (string #\x #\y #\z) => "xyz"
          (string)             => ""

 -- Scheme Procedure: list->string lst
 -- C Function: scm_string (lst)
     Return a newly allocated string made from a list of characters.

          (list->string '(#\a #\b #\c)) => "abc"

 -- Scheme Procedure: reverse-list->string lst
 -- C Function: scm_reverse_list_to_string (lst)
     Return a newly allocated string made from a list of characters, in
     reverse order.

          (reverse-list->string '(#\a #\B #\c)) => "cBa"

 -- Scheme Procedure: make-string k [chr]
 -- C Function: scm_make_string (k, chr)
     Return a newly allocated string of length K.  If CHR is given,
     then all elements of the string are initialized to CHR, otherwise
     the contents of the string are unspecified.

 -- C Function: SCM scm_c_make_string (size_t len, SCM chr)
     Like `scm_make_string', but expects the length as a `size_t'.

 -- Scheme Procedure: string-tabulate proc len
 -- C Function: scm_string_tabulate (proc, len)
     PROC is an integer->char procedure.  Construct a string of size
     LEN by applying PROC to each index to produce the corresponding
     string element.  The order in which PROC is applied to the indices
     is not specified.

 -- Scheme Procedure: string-join ls [delimiter [grammar]]
 -- C Function: scm_string_join (ls, delimiter, grammar)
     Append the string in the string list LS, using the string
     DELIMITER as a delimiter between the elements of LS.  GRAMMAR is a
     symbol which specifies how the delimiter is placed between the
     strings, and defaults to the symbol `infix'.

    `infix'
          Insert the separator between list elements.  An empty string
          will produce an empty list.

    `strict-infix'
          Like `infix', but will raise an error if given the empty list.

    `suffix'
          Insert the separator after every list element.

    `prefix'
          Insert the separator before each list element.


File: guile.info,  Node: List/String Conversion,  Next: String Selection,  Prev: String Constructors,  Up: Strings

6.6.5.4 List/String conversion
..............................

When processing strings, it is often convenient to first convert them
into a list representation by using the procedure `string->list', work
with the resulting list, and then convert it back into a string.  These
procedures are useful for similar tasks.

 -- Scheme Procedure: string->list str [start [end]]
 -- C Function: scm_substring_to_list (str, start, end)
 -- C Function: scm_string_to_list (str)
     Convert the string STR into a list of characters.

 -- Scheme Procedure: string-split str char_pred
 -- C Function: scm_string_split (str, char_pred)
     Split the string STR into a list of substrings delimited by
     appearances of characters that

        * equal CHAR_PRED, if it is a character,

        * satisfy the predicate CHAR_PRED, if it is a procedure,

        * are in the set CHAR_PRED, if it is a character set.

     Note that an empty substring between separator characters will
     result in an empty string in the result list.

          (string-split "root:x:0:0:root:/root:/bin/bash" #\:)
          =>
          ("root" "x" "0" "0" "root" "/root" "/bin/bash")

          (string-split "::" #\:)
          =>
          ("" "" "")

          (string-split "" #\:)
          =>
          ("")


File: guile.info,  Node: String Selection,  Next: String Modification,  Prev: List/String Conversion,  Up: Strings

6.6.5.5 String Selection
........................

Portions of strings can be extracted by these procedures.  `string-ref'
delivers individual characters whereas `substring' can be used to
extract substrings from longer strings.

 -- Scheme Procedure: string-length string
 -- C Function: scm_string_length (string)
     Return the number of characters in STRING.

 -- C Function: size_t scm_c_string_length (SCM str)
     Return the number of characters in STR as a `size_t'.

 -- Scheme Procedure: string-ref str k
 -- C Function: scm_string_ref (str, k)
     Return character K of STR using zero-origin indexing. K must be a
     valid index of STR.

 -- C Function: SCM scm_c_string_ref (SCM str, size_t k)
     Return character K of STR using zero-origin indexing. K must be a
     valid index of STR.

 -- Scheme Procedure: string-copy str [start [end]]
 -- C Function: scm_substring_copy (str, start, end)
 -- C Function: scm_string_copy (str)
     Return a copy of the given string STR.

     The returned string shares storage with STR initially, but it is
     copied as soon as one of the two strings is modified.

 -- Scheme Procedure: substring str start [end]
 -- C Function: scm_substring (str, start, end)
     Return a new string formed from the characters of STR beginning
     with index START (inclusive) and ending with index END (exclusive).
     STR must be a string, START and END must be exact integers
     satisfying:

     0 <= START <= END <= `(string-length STR)'.

     The returned string shares storage with STR initially, but it is
     copied as soon as one of the two strings is modified.

 -- Scheme Procedure: substring/shared str start [end]
 -- C Function: scm_substring_shared (str, start, end)
     Like `substring', but the strings continue to share their storage
     even if they are modified.  Thus, modifications to STR show up in
     the new string, and vice versa.

 -- Scheme Procedure: substring/copy str start [end]
 -- C Function: scm_substring_copy (str, start, end)
     Like `substring', but the storage for the new string is copied
     immediately.

 -- Scheme Procedure: substring/read-only str start [end]
 -- C Function: scm_substring_read_only (str, start, end)
     Like `substring', but the resulting string can not be modified.

 -- C Function: SCM scm_c_substring (SCM str, size_t start, size_t end)
 -- C Function: SCM scm_c_substring_shared (SCM str, size_t start,
          size_t end)
 -- C Function: SCM scm_c_substring_copy (SCM str, size_t start, size_t
          end)
 -- C Function: SCM scm_c_substring_read_only (SCM str, size_t start,
          size_t end)
     Like `scm_substring', etc. but the bounds are given as a `size_t'.

 -- Scheme Procedure: string-take s n
 -- C Function: scm_string_take (s, n)
     Return the N first characters of S.

 -- Scheme Procedure: string-drop s n
 -- C Function: scm_string_drop (s, n)
     Return all but the first N characters of S.

 -- Scheme Procedure: string-take-right s n
 -- C Function: scm_string_take_right (s, n)
     Return the N last characters of S.

 -- Scheme Procedure: string-drop-right s n
 -- C Function: scm_string_drop_right (s, n)
     Return all but the last N characters of S.

 -- Scheme Procedure: string-pad s len [chr [start [end]]]
 -- Scheme Procedure: string-pad-right s len [chr [start [end]]]
 -- C Function: scm_string_pad (s, len, chr, start, end)
 -- C Function: scm_string_pad_right (s, len, chr, start, end)
     Take characters START to END from the string S and either pad with
     CHR or truncate them to give LEN characters.

     `string-pad' pads or truncates on the left, so for example

          (string-pad "x" 3)     => "  x"
          (string-pad "abcde" 3) => "cde"

     `string-pad-right' pads or truncates on the right, so for example

          (string-pad-right "x" 3)     => "x  "
          (string-pad-right "abcde" 3) => "abc"

 -- Scheme Procedure: string-trim s [char_pred [start [end]]]
 -- Scheme Procedure: string-trim-right s [char_pred [start [end]]]
 -- Scheme Procedure: string-trim-both s [char_pred [start [end]]]
 -- C Function: scm_string_trim (s, char_pred, start, end)
 -- C Function: scm_string_trim_right (s, char_pred, start, end)
 -- C Function: scm_string_trim_both (s, char_pred, start, end)
     Trim occurrences of CHAR_PRED from the ends of S.

     `string-trim' trims CHAR_PRED characters from the left (start) of
     the string, `string-trim-right' trims them from the right (end) of
     the string, `string-trim-both' trims from both ends.

     CHAR_PRED can be a character, a character set, or a predicate
     procedure to call on each character.  If CHAR_PRED is not given
     the default is whitespace as per `char-set:whitespace' (*note
     Standard Character Sets::).

          (string-trim " x ")              => "x "
          (string-trim-right "banana" #\a) => "banan"
          (string-trim-both ".,xy:;" char-set:punctuation)
                            => "xy"
          (string-trim-both "xyzzy" (lambda (c)
                                       (or (eqv? c #\x)
                                           (eqv? c #\y))))
                            => "zz"


File: guile.info,  Node: String Modification,  Next: String Comparison,  Prev: String Selection,  Up: Strings

6.6.5.6 String Modification
...........................

These procedures are for modifying strings in-place.  This means that
the result of the operation is not a new string; instead, the original
string's memory representation is modified.

 -- Scheme Procedure: string-set! str k chr
 -- C Function: scm_string_set_x (str, k, chr)
     Store CHR in element K of STR and return an unspecified value. K
     must be a valid index of STR.

 -- C Function: void scm_c_string_set_x (SCM str, size_t k, SCM chr)
     Like `scm_string_set_x', but the index is given as a `size_t'.

 -- Scheme Procedure: string-fill! str chr [start [end]]
 -- C Function: scm_substring_fill_x (str, chr, start, end)
 -- C Function: scm_string_fill_x (str, chr)
     Stores CHR in every element of the given STR and returns an
     unspecified value.

 -- Scheme Procedure: substring-fill! str start end fill
 -- C Function: scm_substring_fill_x (str, start, end, fill)
     Change every character in STR between START and END to FILL.

          (define y (string-copy "abcdefg"))
          (substring-fill! y 1 3 #\r)
          y
          => "arrdefg"

 -- Scheme Procedure: substring-move! str1 start1 end1 str2 start2
 -- C Function: scm_substring_move_x (str1, start1, end1, str2, start2)
     Copy the substring of STR1 bounded by START1 and END1 into STR2
     beginning at position START2.  STR1 and STR2 can be the same
     string.

 -- Scheme Procedure: string-copy! target tstart s [start [end]]
 -- C Function: scm_string_copy_x (target, tstart, s, start, end)
     Copy the sequence of characters from index range [START, END) in
     string S to string TARGET, beginning at index TSTART.  The
     characters are copied left-to-right or right-to-left as needed -
     the copy is guaranteed to work, even if TARGET and S are the same
     string.  It is an error if the copy operation runs off the end of
     the target string.


File: guile.info,  Node: String Comparison,  Next: String Searching,  Prev: String Modification,  Up: Strings

6.6.5.7 String Comparison
.........................

The procedures in this section are similar to the character ordering
predicates (*note Characters::), but are defined on character sequences.

   The first set is specified in R5RS and has names that end in `?'.
The second set is specified in SRFI-13 and the names have not ending
`?'.

   The predicates ending in `-ci' ignore the character case when
comparing strings.  For now, case-insensitive comparison is done using
the R5RS rules, where every lower-case character that has a single
character upper-case form is converted to uppercase before comparison.
See *Note the `(ice-9 i18n)' module: Text Collation, for
locale-dependent string comparison.

 -- Scheme Procedure: string=? s1 s2 s3 ...
     Lexicographic equality predicate; return `#t' if all strings are
     the same length and contain the same characters in the same
     positions, otherwise return `#f'.

     The procedure `string-ci=?' treats upper and lower case letters as
     though they were the same character, but `string=?' treats upper
     and lower case as distinct characters.

 -- Scheme Procedure: string<? s1 s2 s3 ...
     Lexicographic ordering predicate; return `#t' if, for every pair of
     consecutive string arguments STR_I and STR_I+1, STR_I is
     lexicographically less than STR_I+1.

 -- Scheme Procedure: string<=? s1 s2 s3 ...
     Lexicographic ordering predicate; return `#t' if, for every pair of
     consecutive string arguments STR_I and STR_I+1, STR_I is
     lexicographically less than or equal to STR_I+1.

 -- Scheme Procedure: string>? s1 s2 s3 ...
     Lexicographic ordering predicate; return `#t' if, for every pair of
     consecutive string arguments STR_I and STR_I+1, STR_I is
     lexicographically greater than STR_I+1.

 -- Scheme Procedure: string>=? s1 s2 s3 ...
     Lexicographic ordering predicate; return `#t' if, for every pair of
     consecutive string arguments STR_I and STR_I+1, STR_I is
     lexicographically greater than or equal to STR_I+1.

 -- Scheme Procedure: string-ci=? s1 s2 s3 ...
     Case-insensitive string equality predicate; return `#t' if all
     strings are the same length and their component characters match
     (ignoring case) at each position; otherwise return `#f'.

 -- Scheme Procedure: string-ci<? s1 s2 s3 ...
     Case insensitive lexicographic ordering predicate; return `#t' if,
     for every pair of consecutive string arguments STR_I and STR_I+1,
     STR_I is lexicographically less than STR_I+1 regardless of case.

 -- Scheme Procedure: string-ci<=? s1 s2 s3 ...
     Case insensitive lexicographic ordering predicate; return `#t' if,
     for every pair of consecutive string arguments STR_I and STR_I+1,
     STR_I is lexicographically less than or equal to STR_I+1
     regardless of case.

 -- Scheme Procedure: string-ci>? s1 s2 s3 ...
     Case insensitive lexicographic ordering predicate; return `#t' if,
     for every pair of consecutive string arguments STR_I and STR_I+1,
     STR_I is lexicographically greater than STR_I+1 regardless of case.

 -- Scheme Procedure: string-ci>=? s1 s2 s3 ...
     Case insensitive lexicographic ordering predicate; return `#t' if,
     for every pair of consecutive string arguments STR_I and STR_I+1,
     STR_I is lexicographically greater than or equal to STR_I+1
     regardless of case.

 -- Scheme Procedure: string-compare s1 s2 proc_lt proc_eq proc_gt
          [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_compare (s1, s2, proc_lt, proc_eq, proc_gt,
          start1, end1, start2, end2)
     Apply PROC_LT, PROC_EQ, PROC_GT to the mismatch index, depending
     upon whether S1 is less than, equal to, or greater than S2.  The
     mismatch index is the largest index I such that for every 0 <= J <
     I, S1[J] = S2[J] - that is, I is the first position that does not
     match.

 -- Scheme Procedure: string-compare-ci s1 s2 proc_lt proc_eq proc_gt
          [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_compare_ci (s1, s2, proc_lt, proc_eq,
          proc_gt, start1, end1, start2, end2)
     Apply PROC_LT, PROC_EQ, PROC_GT to the mismatch index, depending
     upon whether S1 is less than, equal to, or greater than S2.  The
     mismatch index is the largest index I such that for every 0 <= J <
     I, S1[J] = S2[J] - that is, I is the first position where the
     lowercased letters do not match.


 -- Scheme Procedure: string= s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_eq (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 and S2 are not equal, a true value otherwise.

 -- Scheme Procedure: string<> s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_neq (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 and S2 are equal, a true value otherwise.

 -- Scheme Procedure: string< s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_lt (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 is greater or equal to S2, a true value
     otherwise.

 -- Scheme Procedure: string> s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_gt (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 is less or equal to S2, a true value otherwise.

 -- Scheme Procedure: string<= s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_le (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 is greater to S2, a true value otherwise.

 -- Scheme Procedure: string>= s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_ge (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 is less to S2, a true value otherwise.

 -- Scheme Procedure: string-ci= s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_ci_eq (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 and S2 are not equal, a true value otherwise.
     The character comparison is done case-insensitively.

 -- Scheme Procedure: string-ci<> s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_ci_neq (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 and S2 are equal, a true value otherwise.  The
     character comparison is done case-insensitively.

 -- Scheme Procedure: string-ci< s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_ci_lt (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 is greater or equal to S2, a true value
     otherwise.  The character comparison is done case-insensitively.

 -- Scheme Procedure: string-ci> s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_ci_gt (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 is less or equal to S2, a true value otherwise.
     The character comparison is done case-insensitively.

 -- Scheme Procedure: string-ci<= s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_ci_le (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 is greater to S2, a true value otherwise.  The
     character comparison is done case-insensitively.

 -- Scheme Procedure: string-ci>= s1 s2 [start1 [end1 [start2 [end2]]]]
 -- C Function: scm_string_ci_ge (s1, s2, start1, end1, start2, end2)
     Return `#f' if S1 is less to S2, a true value otherwise.  The
     character comparison is done case-insensitively.

 -- Scheme Procedure: string-hash s [bound [start [end]]]
 -- C Function: scm_substring_hash (s, bound, start, end)
     Compute a hash value for S.  The optional argument BOUND is a
     non-negative exact integer specifying the range of the hash
     function. A positive value restricts the return value to the range
     [0,bound).

 -- Scheme Procedure: string-hash-ci s [bound [start [end]]]
 -- C Function: scm_substring_hash_ci (s, bound, start, end)
     Compute a hash value for S.  The optional argument BOUND is a
     non-negative exact integer specifying the range of the hash
     function. A positive value restricts the return value to the range
     [0,bound).

   Because the same visual appearance of an abstract Unicode character
can be obtained via multiple sequences of Unicode characters, even the
case-insensitive string comparison functions described above may return
`#f' when presented with strings containing different representations
of the same character.  For example, the Unicode character "LATIN SMALL
LETTER S WITH DOT BELOW AND DOT ABOVE" can be represented with a single
character (U+1E69) or by the character "LATIN SMALL LETTER S" (U+0073)
followed by the combining marks "COMBINING DOT BELOW" (U+0323) and
"COMBINING DOT ABOVE" (U+0307).

   For this reason, it is often desirable to ensure that the strings to
be compared are using a mutually consistent representation for every
character.  The Unicode standard defines two methods of normalizing the
contents of strings: Decomposition, which breaks composite characters
into a set of constituent characters with an ordering defined by the
Unicode Standard; and composition, which performs the converse.

   There are two decomposition operations.  "Canonical decomposition"
produces character sequences that share the same visual appearance as
the original characters, while "compatibility decomposition" produces
ones whose visual appearances may differ from the originals but which
represent the same abstract character.

   These operations are encapsulated in the following set of
normalization forms:

"NFD"
     Characters are decomposed to their canonical forms.

"NFKD"
     Characters are decomposed to their compatibility forms.

"NFC"
     Characters are decomposed to their canonical forms, then composed.

"NFKC"
     Characters are decomposed to their compatibility forms, then
     composed.


   The functions below put their arguments into one of the forms
described above.

 -- Scheme Procedure: string-normalize-nfd s
 -- C Function: scm_string_normalize_nfd (s)
     Return the `NFD' normalized form of S.

 -- Scheme Procedure: string-normalize-nfkd s
 -- C Function: scm_string_normalize_nfkd (s)
     Return the `NFKD' normalized form of S.

 -- Scheme Procedure: string-normalize-nfc s
 -- C Function: scm_string_normalize_nfc (s)
     Return the `NFC' normalized form of S.

 -- Scheme Procedure: string-normalize-nfkc s
 -- C Function: scm_string_normalize_nfkc (s)
     Return the `NFKC' normalized form of S.


File: guile.info,  Node: String Searching,  Next: Alphabetic Case Mapping,  Prev: String Comparison,  Up: Strings

6.6.5.8 String Searching
........................

 -- Scheme Procedure: string-index s char_pred [start [end]]
 -- C Function: scm_string_index (s, char_pred, start, end)
     Search through the string S from left to right, returning the
     index of the first occurrence of a character which

        * equals CHAR_PRED, if it is character,

        * satisfies the predicate CHAR_PRED, if it is a procedure,

        * is in the set CHAR_PRED, if it is a character set.

     Return `#f' if no match is found.

 -- Scheme Procedure: string-rindex s char_pred [start [end]]
 -- C Function: scm_string_rindex (s, char_pred, start, end)
     Search through the string S from right to left, returning the
     index of the last occurrence of a character which

        * equals CHAR_PRED, if it is character,

        * satisfies the predicate CHAR_PRED, if it is a procedure,

        * is in the set if CHAR_PRED is a character set.

     Return `#f' if no match is found.

 -- Scheme Procedure: string-prefix-length s1 s2 [start1 [end1 [start2
          [end2]]]]
 -- C Function: scm_string_prefix_length (s1, s2, start1, end1, start2,
          end2)
     Return the length of the longest common prefix of the two strings.

 -- Scheme Procedure: string-prefix-length-ci s1 s2 [start1 [end1
          [start2 [end2]]]]
 -- C Function: scm_string_prefix_length_ci (s1, s2, start1, end1,
          start2, end2)
     Return the length of the longest common prefix of the two strings,
     ignoring character case.

 -- Scheme Procedure: string-suffix-length s1 s2 [start1 [end1 [start2
          [end2]]]]
 -- C Function: scm_string_suffix_length (s1, s2, start1, end1, start2,
          end2)
     Return the length of the longest common suffix of the two strings.

 -- Scheme Procedure: string-suffix-length-ci s1 s2 [start1 [end1
          [start2 [end2]]]]
 -- C Function: scm_string_suffix_length_ci (s1, s2, start1, end1,
          start2, end2)
     Return the length of the longest common suffix of the two strings,
     ignoring character case.

 -- Scheme Procedure: string-prefix? s1 s2 [start1 [end1 [start2
          [end2]]]]
 -- C Function: scm_string_prefix_p (s1, s2, start1, end1, start2, end2)
     Is S1 a prefix of S2?

 -- Scheme Procedure: string-prefix-ci? s1 s2 [start1 [end1 [start2
          [end2]]]]
 -- C Function: scm_string_prefix_ci_p (s1, s2, start1, end1, start2,
          end2)
     Is S1 a prefix of S2, ignoring character case?

 -- Scheme Procedure: string-suffix? s1 s2 [start1 [end1 [start2
          [end2]]]]
 -- C Function: scm_string_suffix_p (s1, s2, start1, end1, start2, end2)
     Is S1 a suffix of S2?

 -- Scheme Procedure: string-suffix-ci? s1 s2 [start1 [end1 [start2
          [end2]]]]
 -- C Function: scm_string_suffix_ci_p (s1, s2, start1, end1, start2,
          end2)
     Is S1 a suffix of S2, ignoring character case?

 -- Scheme Procedure: string-index-right s char_pred [start [end]]
 -- C Function: scm_string_index_right (s, char_pred, start, end)
     Search through the string S from right to left, returning the
     index of the last occurrence of a character which

        * equals CHAR_PRED, if it is character,

        * satisfies the predicate CHAR_PRED, if it is a procedure,

        * is in the set if CHAR_PRED is a character set.

     Return `#f' if no match is found.

 -- Scheme Procedure: string-skip s char_pred [start [end]]
 -- C Function: scm_string_skip (s, char_pred, start, end)
     Search through the string S from left to right, returning the
     index of the first occurrence of a character which

        * does not equal CHAR_PRED, if it is character,

        * does not satisfy the predicate CHAR_PRED, if it is a
          procedure,

        * is not in the set if CHAR_PRED is a character set.

 -- Scheme Procedure: string-skip-right s char_pred [start [end]]
 -- C Function: scm_string_skip_right (s, char_pred, start, end)
     Search through the string S from right to left, returning the
     index of the last occurrence of a character which

        * does not equal CHAR_PRED, if it is character,

        * does not satisfy the predicate CHAR_PRED, if it is a
          procedure,

        * is not in the set if CHAR_PRED is a character set.

 -- Scheme Procedure: string-count s char_pred [start [end]]
 -- C Function: scm_string_count (s, char_pred, start, end)
     Return the count of the number of characters in the string S which

        * equals CHAR_PRED, if it is character,

        * satisfies the predicate CHAR_PRED, if it is a procedure.

        * is in the set CHAR_PRED, if it is a character set.

 -- Scheme Procedure: string-contains s1 s2 [start1 [end1 [start2
          [end2]]]]
 -- C Function: scm_string_contains (s1, s2, start1, end1, start2, end2)
     Does string S1 contain string S2?  Return the index in S1 where S2
     occurs as a substring, or false.  The optional start/end indices
     restrict the operation to the indicated substrings.

 -- Scheme Procedure: string-contains-ci s1 s2 [start1 [end1 [start2
          [end2]]]]
 -- C Function: scm_string_contains_ci (s1, s2, start1, end1, start2,
          end2)
     Does string S1 contain string S2?  Return the index in S1 where S2
     occurs as a substring, or false.  The optional start/end indices
     restrict the operation to the indicated substrings.  Character
     comparison is done case-insensitively.


File: guile.info,  Node: Alphabetic Case Mapping,  Next: Reversing and Appending Strings,  Prev: String Searching,  Up: Strings

6.6.5.9 Alphabetic Case Mapping
...............................

These are procedures for mapping strings to their upper- or lower-case
equivalents, respectively, or for capitalizing strings.

   They use the basic case mapping rules for Unicode characters.  No
special language or context rules are considered.  The resulting strings
are guaranteed to be the same length as the input strings.

   *Note the `(ice-9 i18n)' module: Character Case Mapping, for
locale-dependent case conversions.

 -- Scheme Procedure: string-upcase str [start [end]]
 -- C Function: scm_substring_upcase (str, start, end)
 -- C Function: scm_string_upcase (str)
     Upcase every character in `str'.

 -- Scheme Procedure: string-upcase! str [start [end]]
 -- C Function: scm_substring_upcase_x (str, start, end)
 -- C Function: scm_string_upcase_x (str)
     Destructively upcase every character in `str'.

          (string-upcase! y)
          => "ARRDEFG"
          y
          => "ARRDEFG"

 -- Scheme Procedure: string-downcase str [start [end]]
 -- C Function: scm_substring_downcase (str, start, end)
 -- C Function: scm_string_downcase (str)
     Downcase every character in STR.

 -- Scheme Procedure: string-downcase! str [start [end]]
 -- C Function: scm_substring_downcase_x (str, start, end)
 -- C Function: scm_string_downcase_x (str)
     Destructively downcase every character in STR.

          y
          => "ARRDEFG"
          (string-downcase! y)
          => "arrdefg"
          y
          => "arrdefg"

 -- Scheme Procedure: string-capitalize str
 -- C Function: scm_string_capitalize (str)
     Return a freshly allocated string with the characters in STR,
     where the first character of every word is capitalized.

 -- Scheme Procedure: string-capitalize! str
 -- C Function: scm_string_capitalize_x (str)
     Upcase the first character of every word in STR destructively and
     return STR.

          y                      => "hello world"
          (string-capitalize! y) => "Hello World"
          y                      => "Hello World"

 -- Scheme Procedure: string-titlecase str [start [end]]
 -- C Function: scm_string_titlecase (str, start, end)
     Titlecase every first character in a word in STR.

 -- Scheme Procedure: string-titlecase! str [start [end]]
 -- C Function: scm_string_titlecase_x (str, start, end)
     Destructively titlecase every first character in a word in STR.


File: guile.info,  Node: Reversing and Appending Strings,  Next: Mapping Folding and Unfolding,  Prev: Alphabetic Case Mapping,  Up: Strings

6.6.5.10 Reversing and Appending Strings
........................................

 -- Scheme Procedure: string-reverse str [start [end]]
 -- C Function: scm_string_reverse (str, start, end)
     Reverse the string STR.  The optional arguments START and END
     delimit the region of STR to operate on.

 -- Scheme Procedure: string-reverse! str [start [end]]
 -- C Function: scm_string_reverse_x (str, start, end)
     Reverse the string STR in-place.  The optional arguments START and
     END delimit the region of STR to operate on.  The return value is
     unspecified.

 -- Scheme Procedure: string-append arg ...
 -- C Function: scm_string_append (args)
     Return a newly allocated string whose characters form the
     concatenation of the given strings, ARG ....

          (let ((h "hello "))
            (string-append h "world"))
          => "hello world"

 -- Scheme Procedure: string-append/shared arg ...
 -- C Function: scm_string_append_shared (args)
     Like `string-append', but the result may share memory with the
     argument strings.

 -- Scheme Procedure: string-concatenate ls
 -- C Function: scm_string_concatenate (ls)
     Append the elements (which must be strings) of LS together into a
     single string.  Guaranteed to return a freshly allocated string.

 -- Scheme Procedure: string-concatenate-reverse ls [final_string [end]]
 -- C Function: scm_string_concatenate_reverse (ls, final_string, end)
     Without optional arguments, this procedure is equivalent to

          (string-concatenate (reverse ls))

     If the optional argument FINAL_STRING is specified, it is consed
     onto the beginning to LS before performing the list-reverse and
     string-concatenate operations.  If END is given, only the
     characters of FINAL_STRING up to index END are used.

     Guaranteed to return a freshly allocated string.

 -- Scheme Procedure: string-concatenate/shared ls
 -- C Function: scm_string_concatenate_shared (ls)
     Like `string-concatenate', but the result may share memory with
     the strings in the list LS.

 -- Scheme Procedure: string-concatenate-reverse/shared ls
          [final_string [end]]
 -- C Function: scm_string_concatenate_reverse_shared (ls,
          final_string, end)
     Like `string-concatenate-reverse', but the result may share memory
     with the strings in the LS arguments.


File: guile.info,  Node: Mapping Folding and Unfolding,  Next: Miscellaneous String Operations,  Prev: Reversing and Appending Strings,  Up: Strings

6.6.5.11 Mapping, Folding, and Unfolding
........................................

 -- Scheme Procedure: string-map proc s [start [end]]
 -- C Function: scm_string_map (proc, s, start, end)
     PROC is a char->char procedure, it is mapped over S.  The order in
     which the procedure is applied to the string elements is not
     specified.

 -- Scheme Procedure: string-map! proc s [start [end]]
 -- C Function: scm_string_map_x (proc, s, start, end)
     PROC is a char->char procedure, it is mapped over S.  The order in
     which the procedure is applied to the string elements is not
     specified.  The string S is modified in-place, the return value is
     not specified.

 -- Scheme Procedure: string-for-each proc s [start [end]]
 -- C Function: scm_string_for_each (proc, s, start, end)
     PROC is mapped over S in left-to-right order.  The return value is
     not specified.

 -- Scheme Procedure: string-for-each-index proc s [start [end]]
 -- C Function: scm_string_for_each_index (proc, s, start, end)
     Call `(PROC i)' for each index i in S, from left to right.

     For example, to change characters to alternately upper and lower
     case,

          (define str (string-copy "studly"))
          (string-for-each-index
              (lambda (i)
                (string-set! str i
                  ((if (even? i) char-upcase char-downcase)
                   (string-ref str i))))
              str)
          str => "StUdLy"

 -- Scheme Procedure: string-fold kons knil s [start [end]]
 -- C Function: scm_string_fold (kons, knil, s, start, end)
     Fold KONS over the characters of S, with KNIL as the terminating
     element, from left to right.  KONS must expect two arguments: The
     actual character and the last result of KONS' application.

 -- Scheme Procedure: string-fold-right kons knil s [start [end]]
 -- C Function: scm_string_fold_right (kons, knil, s, start, end)
     Fold KONS over the characters of S, with KNIL as the terminating
     element, from right to left.  KONS must expect two arguments: The
     actual character and the last result of KONS' application.

 -- Scheme Procedure: string-unfold p f g seed [base [make_final]]
 -- C Function: scm_string_unfold (p, f, g, seed, base, make_final)
        * G is used to generate a series of _seed_ values from the
          initial SEED: SEED, (G SEED), (G^2 SEED), (G^3 SEED), ...

        * P tells us when to stop - when it returns true when applied
          to one of these seed values.

        * F maps each seed value to the corresponding character in the
          result string.  These chars are assembled into the string in
          a left-to-right order.

        * BASE is the optional initial/leftmost portion of the
          constructed string; it default to the empty string.

        * MAKE_FINAL is applied to the terminal seed value (on which P
          returns true) to produce the final/rightmost portion of the
          constructed string.  The default is nothing extra.

 -- Scheme Procedure: string-unfold-right p f g seed [base [make_final]]
 -- C Function: scm_string_unfold_right (p, f, g, seed, base,
          make_final)
        * G is used to generate a series of _seed_ values from the
          initial SEED: SEED, (G SEED), (G^2 SEED), (G^3 SEED), ...

        * P tells us when to stop - when it returns true when applied
          to one of these seed values.

        * F maps each seed value to the corresponding character in the
          result string.  These chars are assembled into the string in
          a right-to-left order.

        * BASE is the optional initial/rightmost portion of the
          constructed string; it default to the empty string.

        * MAKE_FINAL is applied to the terminal seed value (on which P
          returns true) to produce the final/leftmost portion of the
          constructed string.  It defaults to `(lambda (x) )'.


File: guile.info,  Node: Miscellaneous String Operations,  Next: Representing Strings as Bytes,  Prev: Mapping Folding and Unfolding,  Up: Strings

6.6.5.12 Miscellaneous String Operations
........................................

 -- Scheme Procedure: xsubstring s from [to [start [end]]]
 -- C Function: scm_xsubstring (s, from, to, start, end)
     This is the _extended substring_ procedure that implements
     replicated copying of a substring of some string.

     S is a string, START and END are optional arguments that demarcate
     a substring of S, defaulting to 0 and the length of S.  Replicate
     this substring up and down index space, in both the positive and
     negative directions.  `xsubstring' returns the substring of this
     string beginning at index FROM, and ending at TO, which defaults
     to FROM + (END - START).

 -- Scheme Procedure: string-xcopy! target tstart s sfrom [sto [start
          [end]]]
 -- C Function: scm_string_xcopy_x (target, tstart, s, sfrom, sto,
          start, end)
     Exactly the same as `xsubstring', but the extracted text is
     written into the string TARGET starting at index TSTART.  The
     operation is not defined if `(eq?  TARGET S)' or these arguments
     share storage - you cannot copy a string on top of itself.

 -- Scheme Procedure: string-replace s1 s2 [start1 [end1 [start2
          [end2]]]]
 -- C Function: scm_string_replace (s1, s2, start1, end1, start2, end2)
     Return the string S1, but with the characters START1 ... END1
     replaced by the characters START2 ... END2 from S2.

 -- Scheme Procedure: string-tokenize s [token_set [start [end]]]
 -- C Function: scm_string_tokenize (s, token_set, start, end)
     Split the string S into a list of substrings, where each substring
     is a maximal non-empty contiguous sequence of characters from the
     character set TOKEN_SET, which defaults to `char-set:graphic'.  If
     START or END indices are provided, they restrict `string-tokenize'
     to operating on the indicated substring of S.

 -- Scheme Procedure: string-filter char_pred s [start [end]]
 -- C Function: scm_string_filter (char_pred, s, start, end)
     Filter the string S, retaining only those characters which satisfy
     CHAR_PRED.

     If CHAR_PRED is a procedure, it is applied to each character as a
     predicate, if it is a character, it is tested for equality and if
     it is a character set, it is tested for membership.

 -- Scheme Procedure: string-delete char_pred s [start [end]]
 -- C Function: scm_string_delete (char_pred, s, start, end)
     Delete characters satisfying CHAR_PRED from S.

     If CHAR_PRED is a procedure, it is applied to each character as a
     predicate, if it is a character, it is tested for equality and if
     it is a character set, it is tested for membership.


File: guile.info,  Node: Representing Strings as Bytes,  Next: Conversion to/from C,  Prev: Miscellaneous String Operations,  Up: Strings

6.6.5.13 Representing Strings as Bytes
......................................

Out in the cold world outside of Guile, not all strings are treated in
the same way.  Out there there are only bytes, and there are many ways
of representing a strings (sequences of characters) as binary data
(sequences of bytes).

   As a user, usually you don't have to think about this very much.
When you type on your keyboard, your system encodes your keystrokes as
bytes according to the locale that you have configured on your computer.
Guile uses the locale to decode those bytes back into characters -
hopefully the same characters that you typed in.

   All is not so clear when dealing with a system with multiple users,
such as a web server.  Your web server might get a request from one
user for data encoded in the ISO-8859-1 character set, and then another
request from a different user for UTF-8 data.

   Guile provides an "iconv" module for converting between strings and
sequences of bytes.  *Note Bytevectors::, for more on how Guile
represents raw byte sequences.  This module gets its name from the
common UNIX command of the same name.

   Note that often it is sufficient to just read and write strings from
ports instead of using these functions.  To do this, specify the port
encoding using `set-port-encoding!'.  *Note Ports::, for more on ports
and character encodings.

   Unlike the rest of the procedures in this section, you have to load
the `iconv' module before having access to these procedures:

     (use-modules (ice-9 iconv))

 -- Scheme Procedure: string->bytevector string encoding
          [conversion-strategy]
     Encode STRING as a sequence of bytes.

     The string will be encoded in the character set specified by the
     ENCODING string.  If the string has characters that cannot be
     represented in the encoding, by default this procedure raises an
     `encoding-error'.  Pass a CONVERSION-STRATEGY argument to specify
     other behaviors.

     The return value is a bytevector.  *Note Bytevectors::, for more on
     bytevectors.  *Note Ports::, for more on character encodings and
     conversion strategies.

 -- Scheme Procedure: bytevector->string bytevector encoding
          [conversion-strategy]
     Decode BYTEVECTOR into a string.

     The bytes will be decoded from the character set by the ENCODING
     string.  If the bytes do not form a valid encoding, by default this
     procedure raises an `decoding-error'.  As with
     `string->bytevector', pass the optional CONVERSION-STRATEGY
     argument to modify this behavior.  *Note Ports::, for more on
     character encodings and conversion strategies.

 -- Scheme Procedure: call-with-output-encoded-string encoding proc
          [conversion-strategy]
     Like `call-with-output-string', but instead of returning a string,
     returns a encoding of the string according to ENCODING, as a
     bytevector.  This procedure can be more efficient than collecting a
     string and then converting it via `string->bytevector'.


File: guile.info,  Node: Conversion to/from C,  Next: String Internals,  Prev: Representing Strings as Bytes,  Up: Strings

6.6.5.14 Conversion to/from C
.............................

When creating a Scheme string from a C string or when converting a
Scheme string to a C string, the concept of character encoding becomes
important.

   In C, a string is just a sequence of bytes, and the character
encoding describes the relation between these bytes and the actual
characters that make up the string.  For Scheme strings, character
encoding is not an issue (most of the time), since in Scheme you
usually treat strings as character sequences, not byte sequences.

   Converting to C and converting from C each have their own challenges.

   When converting from C to Scheme, it is important that the sequence
of bytes in the C string be valid with respect to its encoding.  ASCII
strings, for example, can't have any bytes greater than 127.  An ASCII
byte greater than 127 is considered _ill-formed_ and cannot be
converted into a Scheme character.

   Problems can occur in the reverse operation as well.  Not all
character encodings can hold all possible Scheme characters.  Some
encodings, like ASCII for example, can only describe a small subset of
all possible characters.  So, when converting to C, one must first
decide what to do with Scheme characters that can't be represented in
the C string.

   Converting a Scheme string to a C string will often allocate fresh
memory to hold the result.  You must take care that this memory is
properly freed eventually.  In many cases, this can be achieved by
using `scm_dynwind_free' inside an appropriate dynwind context, *Note
Dynamic Wind::.

 -- C Function: SCM scm_from_locale_string (const char *str)
 -- C Function: SCM scm_from_locale_stringn (const char *str, size_t
          len)
     Creates a new Scheme string that has the same contents as STR when
     interpreted in the character encoding of the current locale.

     For `scm_from_locale_string', STR must be null-terminated.

     For `scm_from_locale_stringn', LEN specifies the length of STR in
     bytes, and STR does not need to be null-terminated.  If LEN is
     `(size_t)-1', then STR does need to be null-terminated and the
     real length will be found with `strlen'.

     If the C string is ill-formed, an error will be raised.

     Note that these functions should _not_ be used to convert C string
     constants, because there is no guarantee that the current locale
     will match that of the execution character set, used for string
     and character constants.  Most modern C compilers use UTF-8 by
     default, so to convert C string constants we recommend
     `scm_from_utf8_string'.

 -- C Function: SCM scm_take_locale_string (char *str)
 -- C Function: SCM scm_take_locale_stringn (char *str, size_t len)
     Like `scm_from_locale_string' and `scm_from_locale_stringn',
     respectively, but also frees STR with `free' eventually.  Thus,
     you can use this function when you would free STR anyway
     immediately after creating the Scheme string.  In certain cases,
     Guile can then use STR directly as its internal representation.

 -- C Function: char * scm_to_locale_string (SCM str)
 -- C Function: char * scm_to_locale_stringn (SCM str, size_t *lenp)
     Returns a C string with the same contents as STR in the character
     encoding of the current locale.  The C string must be freed with
     `free' eventually, maybe by using `scm_dynwind_free', *Note
     Dynamic Wind::.

     For `scm_to_locale_string', the returned string is null-terminated
     and an error is signalled when STR contains `#\nul' characters.

     For `scm_to_locale_stringn' and LENP not `NULL', STR might contain
     `#\nul' characters and the length of the returned string in bytes
     is stored in `*LENP'.  The returned string will not be
     null-terminated in this case.  If LENP is `NULL',
     `scm_to_locale_stringn' behaves like `scm_to_locale_string'.

     If a character in STR cannot be represented in the character
     encoding of the current locale, the default port conversion
     strategy is used.  *Note Ports::, for more on conversion
     strategies.

     If the conversion strategy is `error', an error will be raised.  If
     it is `substitute', a replacement character, such as a question
     mark, will be inserted in its place.  If it is `escape', a hex
     escape will be inserted in its place.

 -- C Function: size_t scm_to_locale_stringbuf (SCM str, char *buf,
          size_t max_len)
     Puts STR as a C string in the current locale encoding into the
     memory pointed to by BUF.  The buffer at BUF has room for MAX_LEN
     bytes and `scm_to_local_stringbuf' will never store more than
     that.  No terminating `'\0'' will be stored.

     The return value of `scm_to_locale_stringbuf' is the number of
     bytes that are needed for all of STR, regardless of whether BUF
     was large enough to hold them.  Thus, when the return value is
     larger than MAX_LEN, only MAX_LEN bytes have been stored and you
     probably need to try again with a larger buffer.

   For most situations, string conversion should occur using the current
locale, such as with the functions above.  But there may be cases where
one wants to convert strings from a character encoding other than the
locale's character encoding.  For these cases, the lower-level functions
`scm_to_stringn' and `scm_from_stringn' are provided.  These functions
should seldom be necessary if one is properly using locales.

 -- C Type: scm_t_string_failed_conversion_handler
     This is an enumerated type that can take one of three values:
     `SCM_FAILED_CONVERSION_ERROR',
     `SCM_FAILED_CONVERSION_QUESTION_MARK', and
     `SCM_FAILED_CONVERSION_ESCAPE_SEQUENCE'.  They are used to indicate
     a strategy for handling characters that cannot be converted to or
     from a given character encoding.  `SCM_FAILED_CONVERSION_ERROR'
     indicates that a conversion should throw an error if some
     characters cannot be converted.
     `SCM_FAILED_CONVERSION_QUESTION_MARK' indicates that a conversion
     should replace unconvertable characters with the question mark
     character.  And, `SCM_FAILED_CONVERSION_ESCAPE_SEQUENCE' requests
     that a conversion should replace an unconvertable character with
     an escape sequence.

     While all three strategies apply when converting Scheme strings to
     C, only `SCM_FAILED_CONVERSION_ERROR' and
     `SCM_FAILED_CONVERSION_QUESTION_MARK' can be used when converting C
     strings to Scheme.

 -- C Function: char *scm_to_stringn (SCM str, size_t *lenp, const char
          *encoding, scm_t_string_failed_conversion_handler handler)
     This function returns a newly allocated C string from the Guile
     string STR.  The length of the returned string in bytes will be
     returned in LENP.  The character encoding of the C string is
     passed as the ASCII, null-terminated C string ENCODING.  The
     HANDLER parameter gives a strategy for dealing with characters
     that cannot be converted into ENCODING.

     If LENP is `NULL', this function will return a null-terminated C
     string.  It will throw an error if the string contains a null
     character.

     The Scheme interface to this function is `string->bytevector',
     from the `ice-9 iconv' module.  *Note Representing Strings as
     Bytes::.

 -- C Function: SCM scm_from_stringn (const char *str, size_t len,
          const char *encoding, scm_t_string_failed_conversion_handler
          handler)
     This function returns a scheme string from the C string STR.  The
     length in bytes of the C string is input as LEN.  The encoding of
     the C string is passed as the ASCII, null-terminated C string
     `encoding'.  The HANDLER parameters suggests a strategy for
     dealing with unconvertable characters.

     The Scheme interface to this function is `bytevector->string'.
     *Note Representing Strings as Bytes::.

   The following conversion functions are provided as a convenience for
the most commonly used encodings.

 -- C Function: SCM scm_from_latin1_string (const char *str)
 -- C Function: SCM scm_from_utf8_string (const char *str)
 -- C Function: SCM scm_from_utf32_string (const scm_t_wchar *str)
     Return a scheme string from the null-terminated C string STR,
     which is ISO-8859-1-, UTF-8-, or UTF-32-encoded.  These functions
     should be used to convert hard-coded C string constants into
     Scheme strings.

 -- C Function: SCM scm_from_latin1_stringn (const char *str, size_t
          len)
 -- C Function: SCM scm_from_utf8_stringn (const char *str, size_t len)
 -- C Function: SCM scm_from_utf32_stringn (const scm_t_wchar *str,
          size_t len)
     Return a scheme string from C string STR, which is ISO-8859-1-,
     UTF-8-, or UTF-32-encoded, of length LEN.  LEN is the number of
     bytes pointed to by STR for `scm_from_latin1_stringn' and
     `scm_from_utf8_stringn'; it is the number of elements (code points)
     in STR in the case of `scm_from_utf32_stringn'.

 -- C function: char *scm_to_latin1_stringn (SCM str, size_t *lenp)
 -- C function: char *scm_to_utf8_stringn (SCM str, size_t *lenp)
 -- C function: scm_t_wchar *scm_to_utf32_stringn (SCM str, size_t
          *lenp)
     Return a newly allocated, ISO-8859-1-, UTF-8-, or UTF-32-encoded C
     string from Scheme string STR.  An error is thrown when STR cannot
     be converted to the specified encoding.  If LENP is `NULL', the
     returned C string will be null terminated, and an error will be
     thrown if the C string would otherwise contain null characters.
     If LENP is not `NULL', the string is not null terminated, and the
     length of the returned string is returned in LENP.  The length
     returned is the number of bytes for `scm_to_latin1_stringn' and
     `scm_to_utf8_stringn'; it is the number of elements (code points)
     for `scm_to_utf32_stringn'.


File: guile.info,  Node: String Internals,  Prev: Conversion to/from C,  Up: Strings

6.6.5.15 String Internals
.........................

Guile stores each string in memory as a contiguous array of Unicode code
points along with an associated set of attributes.  If all of the code
points of a string have an integer range between 0 and 255 inclusive,
the code point array is stored as one byte per code point: it is stored
as an ISO-8859-1 (aka Latin-1) string.  If any of the code points of the
string has an integer value greater that 255, the code point array is
stored as four bytes per code point: it is stored as a UTF-32 string.

   Conversion between the one-byte-per-code-point and
four-bytes-per-code-point representations happens automatically as
necessary.

   No API is provided to set the internal representation of strings;
however, there are pair of procedures available to query it.  These are
debugging procedures.  Using them in production code is discouraged,
since the details of Guile's internal representation of strings may
change from release to release.

 -- Scheme Procedure: string-bytes-per-char str
 -- C Function: scm_string_bytes_per_char (str)
     Return the number of bytes used to encode a Unicode code point in
     string STR.  The result is one or four.

 -- Scheme Procedure: %string-dump str
 -- C Function: scm_sys_string_dump (str)
     Returns an association list containing debugging information for
     STR. The association list has the following entries.
    `string'
          The string itself.

    `start'
          The start index of the string into its stringbuf

    `length'
          The length of the string

    `shared'
          If this string is a substring, it returns its parent string.
          Otherwise, it returns `#f'

    `read-only'
          `#t' if the string is read-only

    `stringbuf-chars'
          A new string containing this string's stringbuf's characters

    `stringbuf-length'
          The number of characters in this stringbuf

    `stringbuf-shared'
          `#t' if this stringbuf is shared

    `stringbuf-wide'
          `#t' if this stringbuf's characters are stored in a 32-bit
          buffer, or `#f' if they are stored in an 8-bit buffer


File: guile.info,  Node: Bytevectors,  Next: Symbols,  Prev: Strings,  Up: Simple Data Types

6.6.6 Bytevectors
-----------------

A "bytevector" is a raw bit string.  The `(rnrs bytevectors)' module
provides the programming interface specified by the Revised^6 Report on
the Algorithmic Language Scheme (R6RS) (http://www.r6rs.org/).  It
contains procedures to manipulate bytevectors and interpret their
contents in a number of ways: bytevector contents can be accessed as
signed or unsigned integer of various sizes and endianness, as IEEE-754
floating point numbers, or as strings.  It is a useful tool to encode
and decode binary data.

   The R6RS (Section 4.3.4) specifies an external representation for
bytevectors, whereby the octets (integers in the range 0-255) contained
in the bytevector are represented as a list prefixed by `#vu8':

     #vu8(1 53 204)

   denotes a 3-byte bytevector containing the octets 1, 53, and 204.
Like string literals, booleans, etc., bytevectors are "self-quoting",
i.e., they do not need to be quoted:

     #vu8(1 53 204)
     => #vu8(1 53 204)

   Bytevectors can be used with the binary input/output primitives of
the R6RS (*note R6RS I/O Ports::).

* Menu:

* Bytevector Endianness::       Dealing with byte order.
* Bytevector Manipulation::     Creating, copying, manipulating bytevectors.
* Bytevectors as Integers::     Interpreting bytes as integers.
* Bytevectors and Integer Lists::  Converting to/from an integer list.
* Bytevectors as Floats::       Interpreting bytes as real numbers.
* Bytevectors as Strings::      Interpreting bytes as Unicode strings.
* Bytevectors as Arrays::       Guile extension to the bytevector API.
* Bytevectors as Uniform Vectors::  Bytevectors and SRFI-4.


File: guile.info,  Node: Bytevector Endianness,  Next: Bytevector Manipulation,  Up: Bytevectors

6.6.6.1 Endianness
..................

Some of the following procedures take an ENDIANNESS parameter.  The
"endianness" is defined as the order of bytes in multi-byte numbers:
numbers encoded in "big endian" have their most significant bytes
written first, whereas numbers encoded in "little endian" have their
least significant bytes first(1).

   Little-endian is the native endianness of the IA32 architecture and
its derivatives, while big-endian is native to SPARC and PowerPC, among
others. The `native-endianness' procedure returns the native endianness
of the machine it runs on.

 -- Scheme Procedure: native-endianness
 -- C Function: scm_native_endianness ()
     Return a value denoting the native endianness of the host machine.

 -- Scheme Macro: endianness symbol
     Return an object denoting the endianness specified by SYMBOL.  If
     SYMBOL is neither `big' nor `little' then an error is raised at
     expand-time.

 -- C Variable: scm_endianness_big
 -- C Variable: scm_endianness_little
     The objects denoting big- and little-endianness, respectively.

   ---------- Footnotes ----------

   (1) Big-endian and little-endian are the most common "endiannesses",
but others do exist. For instance, the GNU MP library allows "word
order" to be specified independently of "byte order" (*note Integer
Import and Export: (gmp)Integer Import and Export.).


File: guile.info,  Node: Bytevector Manipulation,  Next: Bytevectors as Integers,  Prev: Bytevector Endianness,  Up: Bytevectors

6.6.6.2 Manipulating Bytevectors
................................

Bytevectors can be created, copied, and analyzed with the following
procedures and C functions.

 -- Scheme Procedure: make-bytevector len [fill]
 -- C Function: scm_make_bytevector (len, fill)
 -- C Function: scm_c_make_bytevector (size_t len)
     Return a new bytevector of LEN bytes.  Optionally, if FILL is
     given, fill it with FILL; FILL must be in the range [-128,255].

 -- Scheme Procedure: bytevector? obj
 -- C Function: scm_bytevector_p (obj)
     Return true if OBJ is a bytevector.

 -- C Function: int scm_is_bytevector (SCM obj)
     Equivalent to `scm_is_true (scm_bytevector_p (obj))'.

 -- Scheme Procedure: bytevector-length bv
 -- C Function: scm_bytevector_length (bv)
     Return the length in bytes of bytevector BV.

 -- C Function: size_t scm_c_bytevector_length (SCM bv)
     Likewise, return the length in bytes of bytevector BV.

 -- Scheme Procedure: bytevector=? bv1 bv2
 -- C Function: scm_bytevector_eq_p (bv1, bv2)
     Return is BV1 equals to BV2--i.e., if they have the same length
     and contents.

 -- Scheme Procedure: bytevector-fill! bv fill
 -- C Function: scm_bytevector_fill_x (bv, fill)
     Fill bytevector BV with FILL, a byte.

 -- Scheme Procedure: bytevector-copy! source source-start target
          target-start len
 -- C Function: scm_bytevector_copy_x (source, source_start, target,
          target_start, len)
     Copy LEN bytes from SOURCE into TARGET, starting reading from
     SOURCE-START (a positive index within SOURCE) and start writing at
     TARGET-START.  It is permitted for the SOURCE and TARGET regions
     to overlap.

 -- Scheme Procedure: bytevector-copy bv
 -- C Function: scm_bytevector_copy (bv)
     Return a newly allocated copy of BV.

 -- C Function: scm_t_uint8 scm_c_bytevector_ref (SCM bv, size_t index)
     Return the byte at INDEX in bytevector BV.

 -- C Function: void scm_c_bytevector_set_x (SCM bv, size_t index,
          scm_t_uint8 value)
     Set the byte at INDEX in BV to VALUE.

   Low-level C macros are available.  They do not perform any
type-checking; as such they should be used with care.

 -- C Macro: size_t SCM_BYTEVECTOR_LENGTH (bv)
     Return the length in bytes of bytevector BV.

 -- C Macro: signed char * SCM_BYTEVECTOR_CONTENTS (bv)
     Return a pointer to the contents of bytevector BV.


File: guile.info,  Node: Bytevectors as Integers,  Next: Bytevectors and Integer Lists,  Prev: Bytevector Manipulation,  Up: Bytevectors

6.6.6.3 Interpreting Bytevector Contents as Integers
....................................................

The contents of a bytevector can be interpreted as a sequence of
integers of any given size, sign, and endianness.

     (let ((bv (make-bytevector 4)))
       (bytevector-u8-set! bv 0 #x12)
       (bytevector-u8-set! bv 1 #x34)
       (bytevector-u8-set! bv 2 #x56)
       (bytevector-u8-set! bv 3 #x78)

       (map (lambda (number)
              (number->string number 16))
            (list (bytevector-u8-ref bv 0)
                  (bytevector-u16-ref bv 0 (endianness big))
                  (bytevector-u32-ref bv 0 (endianness little)))))

     => ("12" "1234" "78563412")

   The most generic procedures to interpret bytevector contents as
integers are described below.

 -- Scheme Procedure: bytevector-uint-ref bv index endianness size
 -- C Function: scm_bytevector_uint_ref (bv, index, endianness, size)
     Return the SIZE-byte long unsigned integer at index INDEX in BV,
     decoded according to ENDIANNESS.

 -- Scheme Procedure: bytevector-sint-ref bv index endianness size
 -- C Function: scm_bytevector_sint_ref (bv, index, endianness, size)
     Return the SIZE-byte long signed integer at index INDEX in BV,
     decoded according to ENDIANNESS.

 -- Scheme Procedure: bytevector-uint-set! bv index value endianness
          size
 -- C Function: scm_bytevector_uint_set_x (bv, index, value,
          endianness, size)
     Set the SIZE-byte long unsigned integer at INDEX to VALUE, encoded
     according to ENDIANNESS.

 -- Scheme Procedure: bytevector-sint-set! bv index value endianness
          size
 -- C Function: scm_bytevector_sint_set_x (bv, index, value,
          endianness, size)
     Set the SIZE-byte long signed integer at INDEX to VALUE, encoded
     according to ENDIANNESS.

   The following procedures are similar to the ones above, but
specialized to a given integer size:

 -- Scheme Procedure: bytevector-u8-ref bv index
 -- Scheme Procedure: bytevector-s8-ref bv index
 -- Scheme Procedure: bytevector-u16-ref bv index endianness
 -- Scheme Procedure: bytevector-s16-ref bv index endianness
 -- Scheme Procedure: bytevector-u32-ref bv index endianness
 -- Scheme Procedure: bytevector-s32-ref bv index endianness
 -- Scheme Procedure: bytevector-u64-ref bv index endianness
 -- Scheme Procedure: bytevector-s64-ref bv index endianness
 -- C Function: scm_bytevector_u8_ref (bv, index)
 -- C Function: scm_bytevector_s8_ref (bv, index)
 -- C Function: scm_bytevector_u16_ref (bv, index, endianness)
 -- C Function: scm_bytevector_s16_ref (bv, index, endianness)
 -- C Function: scm_bytevector_u32_ref (bv, index, endianness)
 -- C Function: scm_bytevector_s32_ref (bv, index, endianness)
 -- C Function: scm_bytevector_u64_ref (bv, index, endianness)
 -- C Function: scm_bytevector_s64_ref (bv, index, endianness)
     Return the unsigned N-bit (signed) integer (where N is 8, 16, 32
     or 64) from BV at INDEX, decoded according to ENDIANNESS.

 -- Scheme Procedure: bytevector-u8-set! bv index value
 -- Scheme Procedure: bytevector-s8-set! bv index value
 -- Scheme Procedure: bytevector-u16-set! bv index value endianness
 -- Scheme Procedure: bytevector-s16-set! bv index value endianness
 -- Scheme Procedure: bytevector-u32-set! bv index value endianness
 -- Scheme Procedure: bytevector-s32-set! bv index value endianness
 -- Scheme Procedure: bytevector-u64-set! bv index value endianness
 -- Scheme Procedure: bytevector-s64-set! bv index value endianness
 -- C Function: scm_bytevector_u8_set_x (bv, index, value)
 -- C Function: scm_bytevector_s8_set_x (bv, index, value)
 -- C Function: scm_bytevector_u16_set_x (bv, index, value, endianness)
 -- C Function: scm_bytevector_s16_set_x (bv, index, value, endianness)
 -- C Function: scm_bytevector_u32_set_x (bv, index, value, endianness)
 -- C Function: scm_bytevector_s32_set_x (bv, index, value, endianness)
 -- C Function: scm_bytevector_u64_set_x (bv, index, value, endianness)
 -- C Function: scm_bytevector_s64_set_x (bv, index, value, endianness)
     Store VALUE as an N-bit (signed) integer (where N is 8, 16, 32 or
     64) in BV at INDEX, encoded according to ENDIANNESS.

   Finally, a variant specialized for the host's endianness is available
for each of these functions (with the exception of the `u8' accessors,
for obvious reasons):

 -- Scheme Procedure: bytevector-u16-native-ref bv index
 -- Scheme Procedure: bytevector-s16-native-ref bv index
 -- Scheme Procedure: bytevector-u32-native-ref bv index
 -- Scheme Procedure: bytevector-s32-native-ref bv index
 -- Scheme Procedure: bytevector-u64-native-ref bv index
 -- Scheme Procedure: bytevector-s64-native-ref bv index
 -- C Function: scm_bytevector_u16_native_ref (bv, index)
 -- C Function: scm_bytevector_s16_native_ref (bv, index)
 -- C Function: scm_bytevector_u32_native_ref (bv, index)
 -- C Function: scm_bytevector_s32_native_ref (bv, index)
 -- C Function: scm_bytevector_u64_native_ref (bv, index)
 -- C Function: scm_bytevector_s64_native_ref (bv, index)
     Return the unsigned N-bit (signed) integer (where N is 8, 16, 32
     or 64) from BV at INDEX, decoded according to the host's native
     endianness.

 -- Scheme Procedure: bytevector-u16-native-set! bv index value
 -- Scheme Procedure: bytevector-s16-native-set! bv index value
 -- Scheme Procedure: bytevector-u32-native-set! bv index value
 -- Scheme Procedure: bytevector-s32-native-set! bv index value
 -- Scheme Procedure: bytevector-u64-native-set! bv index value
 -- Scheme Procedure: bytevector-s64-native-set! bv index value
 -- C Function: scm_bytevector_u16_native_set_x (bv, index, value)
 -- C Function: scm_bytevector_s16_native_set_x (bv, index, value)
 -- C Function: scm_bytevector_u32_native_set_x (bv, index, value)
 -- C Function: scm_bytevector_s32_native_set_x (bv, index, value)
 -- C Function: scm_bytevector_u64_native_set_x (bv, index, value)
 -- C Function: scm_bytevector_s64_native_set_x (bv, index, value)
     Store VALUE as an N-bit (signed) integer (where N is 8, 16, 32 or
     64) in BV at INDEX, encoded according to the host's native
     endianness.


File: guile.info,  Node: Bytevectors and Integer Lists,  Next: Bytevectors as Floats,  Prev: Bytevectors as Integers,  Up: Bytevectors

6.6.6.4 Converting Bytevectors to/from Integer Lists
....................................................

Bytevector contents can readily be converted to/from lists of signed or
unsigned integers:

     (bytevector->sint-list (u8-list->bytevector (make-list 4 255))
                            (endianness little) 2)
     => (-1 -1)

 -- Scheme Procedure: bytevector->u8-list bv
 -- C Function: scm_bytevector_to_u8_list (bv)
     Return a newly allocated list of unsigned 8-bit integers from the
     contents of BV.

 -- Scheme Procedure: u8-list->bytevector lst
 -- C Function: scm_u8_list_to_bytevector (lst)
     Return a newly allocated bytevector consisting of the unsigned
     8-bit integers listed in LST.

 -- Scheme Procedure: bytevector->uint-list bv endianness size
 -- C Function: scm_bytevector_to_uint_list (bv, endianness, size)
     Return a list of unsigned integers of SIZE bytes representing the
     contents of BV, decoded according to ENDIANNESS.

 -- Scheme Procedure: bytevector->sint-list bv endianness size
 -- C Function: scm_bytevector_to_sint_list (bv, endianness, size)
     Return a list of signed integers of SIZE bytes representing the
     contents of BV, decoded according to ENDIANNESS.

 -- Scheme Procedure: uint-list->bytevector lst endianness size
 -- C Function: scm_uint_list_to_bytevector (lst, endianness, size)
     Return a new bytevector containing the unsigned integers listed in
     LST and encoded on SIZE bytes according to ENDIANNESS.

 -- Scheme Procedure: sint-list->bytevector lst endianness size
 -- C Function: scm_sint_list_to_bytevector (lst, endianness, size)
     Return a new bytevector containing the signed integers listed in
     LST and encoded on SIZE bytes according to ENDIANNESS.


File: guile.info,  Node: Bytevectors as Floats,  Next: Bytevectors as Strings,  Prev: Bytevectors and Integer Lists,  Up: Bytevectors

6.6.6.5 Interpreting Bytevector Contents as Floating Point Numbers
..................................................................

Bytevector contents can also be accessed as IEEE-754 single- or
double-precision floating point numbers (respectively 32 and 64-bit
long) using the procedures described here.

 -- Scheme Procedure: bytevector-ieee-single-ref bv index endianness
 -- Scheme Procedure: bytevector-ieee-double-ref bv index endianness
 -- C Function: scm_bytevector_ieee_single_ref (bv, index, endianness)
 -- C Function: scm_bytevector_ieee_double_ref (bv, index, endianness)
     Return the IEEE-754 single-precision floating point number from BV
     at INDEX according to ENDIANNESS.

 -- Scheme Procedure: bytevector-ieee-single-set! bv index value
          endianness
 -- Scheme Procedure: bytevector-ieee-double-set! bv index value
          endianness
 -- C Function: scm_bytevector_ieee_single_set_x (bv, index, value,
          endianness)
 -- C Function: scm_bytevector_ieee_double_set_x (bv, index, value,
          endianness)
     Store real number VALUE in BV at INDEX according to ENDIANNESS.

   Specialized procedures are also available:

 -- Scheme Procedure: bytevector-ieee-single-native-ref bv index
 -- Scheme Procedure: bytevector-ieee-double-native-ref bv index
 -- C Function: scm_bytevector_ieee_single_native_ref (bv, index)
 -- C Function: scm_bytevector_ieee_double_native_ref (bv, index)
     Return the IEEE-754 single-precision floating point number from BV
     at INDEX according to the host's native endianness.

 -- Scheme Procedure: bytevector-ieee-single-native-set! bv index value
 -- Scheme Procedure: bytevector-ieee-double-native-set! bv index value
 -- C Function: scm_bytevector_ieee_single_native_set_x (bv, index,
          value)
 -- C Function: scm_bytevector_ieee_double_native_set_x (bv, index,
          value)
     Store real number VALUE in BV at INDEX according to the host's
     native endianness.


File: guile.info,  Node: Bytevectors as Strings,  Next: Bytevectors as Arrays,  Prev: Bytevectors as Floats,  Up: Bytevectors

6.6.6.6 Interpreting Bytevector Contents as Unicode Strings
...........................................................

Bytevector contents can also be interpreted as Unicode strings encoded
in one of the most commonly available encoding formats.  *Note
Representing Strings as Bytes::, for a more generic interface.

     (utf8->string (u8-list->bytevector '(99 97 102 101)))
     => "cafe"

     (string->utf8 "caf") ;; SMALL LATIN LETTER E WITH ACUTE ACCENT
     => #vu8(99 97 102 195 169)

 -- Scheme Procedure: string->utf8 str
 -- Scheme Procedure: string->utf16 str [endianness]
 -- Scheme Procedure: string->utf32 str [endianness]
 -- C Function: scm_string_to_utf8 (str)
 -- C Function: scm_string_to_utf16 (str, endianness)
 -- C Function: scm_string_to_utf32 (str, endianness)
     Return a newly allocated bytevector that contains the UTF-8,
     UTF-16, or UTF-32 (aka. UCS-4) encoding of STR.  For UTF-16 and
     UTF-32, ENDIANNESS should be the symbol `big' or `little'; when
     omitted, it defaults to big endian.

 -- Scheme Procedure: utf8->string utf
 -- Scheme Procedure: utf16->string utf [endianness]
 -- Scheme Procedure: utf32->string utf [endianness]
 -- C Function: scm_utf8_to_string (utf)
 -- C Function: scm_utf16_to_string (utf, endianness)
 -- C Function: scm_utf32_to_string (utf, endianness)
     Return a newly allocated string that contains from the UTF-8-,
     UTF-16-, or UTF-32-decoded contents of bytevector UTF.  For UTF-16
     and UTF-32, ENDIANNESS should be the symbol `big' or `little';
     when omitted, it defaults to big endian.


File: guile.info,  Node: Bytevectors as Arrays,  Next: Bytevectors as Uniform Vectors,  Prev: Bytevectors as Strings,  Up: Bytevectors

6.6.6.7 Accessing Bytevectors with the Array API
................................................

As an extension to the R6RS, Guile allows bytevectors to be manipulated
with the "array" procedures (*note Arrays::).  When using these APIs,
bytes are accessed one at a time as 8-bit unsigned integers:

     (define bv #vu8(0 1 2 3))

     (array? bv)
     => #t

     (array-rank bv)
     => 1

     (array-ref bv 2)
     => 2

     ;; Note the different argument order on array-set!.
     (array-set! bv 77 2)
     (array-ref bv 2)
     => 77

     (array-type bv)
     => vu8


File: guile.info,  Node: Bytevectors as Uniform Vectors,  Prev: Bytevectors as Arrays,  Up: Bytevectors

6.6.6.8 Accessing Bytevectors with the SRFI-4 API
.................................................

Bytevectors may also be accessed with the SRFI-4 API. *Note SRFI-4 and
Bytevectors::, for more information.


File: guile.info,  Node: Symbols,  Next: Keywords,  Prev: Bytevectors,  Up: Simple Data Types

6.6.7 Symbols
-------------

Symbols in Scheme are widely used in three ways: as items of discrete
data, as lookup keys for alists and hash tables, and to denote variable
references.

   A "symbol" is similar to a string in that it is defined by a
sequence of characters.  The sequence of characters is known as the
symbol's "name".  In the usual case -- that is, where the symbol's name
doesn't include any characters that could be confused with other
elements of Scheme syntax -- a symbol is written in a Scheme program by
writing the sequence of characters that make up the name, _without_ any
quotation marks or other special syntax.  For example, the symbol whose
name is "multiply-by-2" is written, simply:

     multiply-by-2

   Notice how this differs from a _string_ with contents
"multiply-by-2", which is written with double quotation marks, like
this:

     "multiply-by-2"

   Looking beyond how they are written, symbols are different from
strings in two important respects.

   The first important difference is uniqueness.  If the same-looking
string is read twice from two different places in a program, the result
is two _different_ string objects whose contents just happen to be the
same.  If, on the other hand, the same-looking symbol is read twice
from two different places in a program, the result is the _same_ symbol
object both times.

   Given two read symbols, you can use `eq?' to test whether they are
the same (that is, have the same name).  `eq?' is the most efficient
comparison operator in Scheme, and comparing two symbols like this is
as fast as comparing, for example, two numbers.  Given two strings, on
the other hand, you must use `equal?' or `string=?', which are much
slower comparison operators, to determine whether the strings have the
same contents.

     (define sym1 (quote hello))
     (define sym2 (quote hello))
     (eq? sym1 sym2) => #t

     (define str1 "hello")
     (define str2 "hello")
     (eq? str1 str2) => #f
     (equal? str1 str2) => #t

   The second important difference is that symbols, unlike strings, are
not self-evaluating.  This is why we need the `(quote ...)'s in the
example above: `(quote hello)' evaluates to the symbol named "hello"
itself, whereas an unquoted `hello' is _read_ as the symbol named
"hello" and evaluated as a variable reference ... about which more
below (*note Symbol Variables::).

* Menu:

* Symbol Data::                 Symbols as discrete data.
* Symbol Keys::                 Symbols as lookup keys.
* Symbol Variables::            Symbols as denoting variables.
* Symbol Primitives::           Operations related to symbols.
* Symbol Props::                Function slots and property lists.
* Symbol Read Syntax::          Extended read syntax for symbols.
* Symbol Uninterned::           Uninterned symbols.


File: guile.info,  Node: Symbol Data,  Next: Symbol Keys,  Up: Symbols

6.6.7.1 Symbols as Discrete Data
................................

Numbers and symbols are similar to the extent that they both lend
themselves to `eq?' comparison.  But symbols are more descriptive than
numbers, because a symbol's name can be used directly to describe the
concept for which that symbol stands.

   For example, imagine that you need to represent some colours in a
computer program.  Using numbers, you would have to choose arbitrarily
some mapping between numbers and colours, and then take care to use that
mapping consistently:

     ;; 1=red, 2=green, 3=purple

     (if (eq? (colour-of car) 1)
         ...)

You can make the mapping more explicit and the code more readable by
defining constants:

     (define red 1)
     (define green 2)
     (define purple 3)

     (if (eq? (colour-of car) red)
         ...)

But the simplest and clearest approach is not to use numbers at all, but
symbols whose names specify the colours that they refer to:

     (if (eq? (colour-of car) 'red)
         ...)

   The descriptive advantages of symbols over numbers increase as the
set of concepts that you want to describe grows.  Suppose that a car
object can have other properties as well, such as whether it has or
uses:

   * automatic or manual transmission

   * leaded or unleaded fuel

   * power steering (or not).

Then a car's combined property set could be naturally represented and
manipulated as a list of symbols:

     (properties-of car1)
     =>
     (red manual unleaded power-steering)

     (if (memq 'power-steering (properties-of car1))
         (display "Unfit people can drive this car.\n")
         (display "You'll need strong arms to drive this car!\n"))
     -|
     Unfit people can drive this car.

   Remember, the fundamental property of symbols that we are relying on
here is that an occurrence of `'red' in one part of a program is an
_indistinguishable_ symbol from an occurrence of `'red' in another part
of a program; this means that symbols can usefully be compared using
`eq?'.  At the same time, symbols have naturally descriptive names.
This combination of efficiency and descriptive power makes them ideal
for use as discrete data.


File: guile.info,  Node: Symbol Keys,  Next: Symbol Variables,  Prev: Symbol Data,  Up: Symbols

6.6.7.2 Symbols as Lookup Keys
..............................

Given their efficiency and descriptive power, it is natural to use
symbols as the keys in an association list or hash table.

   To illustrate this, consider a more structured representation of the
car properties example from the preceding subsection.  Rather than
mixing all the properties up together in a flat list, we could use an
association list like this:

     (define car1-properties '((colour . red)
                               (transmission . manual)
                               (fuel . unleaded)
                               (steering . power-assisted)))

   Notice how this structure is more explicit and extensible than the
flat list.  For example it makes clear that `manual' refers to the
transmission rather than, say, the windows or the locking of the car.
It also allows further properties to use the same symbols among their
possible values without becoming ambiguous:

     (define car1-properties '((colour . red)
                               (transmission . manual)
                               (fuel . unleaded)
                               (steering . power-assisted)
                               (seat-colour . red)
                               (locking . manual)))

   With a representation like this, it is easy to use the efficient
`assq-XXX' family of procedures (*note Association Lists::) to extract
or change individual pieces of information:

     (assq-ref car1-properties 'fuel) => unleaded
     (assq-ref car1-properties 'transmission) => manual

     (assq-set! car1-properties 'seat-colour 'black)
     =>
     ((colour . red)
      (transmission . manual)
      (fuel . unleaded)
      (steering . power-assisted)
      (seat-colour . black)
      (locking . manual)))

   Hash tables also have keys, and exactly the same arguments apply to
the use of symbols in hash tables as in association lists.  The hash
value that Guile uses to decide where to add a symbol-keyed entry to a
hash table can be obtained by calling the `symbol-hash' procedure:

 -- Scheme Procedure: symbol-hash symbol
 -- C Function: scm_symbol_hash (symbol)
     Return a hash value for SYMBOL.

   See *note Hash Tables:: for information about hash tables in
general, and for why you might choose to use a hash table rather than
an association list.


File: guile.info,  Node: Symbol Variables,  Next: Symbol Primitives,  Prev: Symbol Keys,  Up: Symbols

6.6.7.3 Symbols as Denoting Variables
.....................................

When an unquoted symbol in a Scheme program is evaluated, it is
interpreted as a variable reference, and the result of the evaluation is
the appropriate variable's value.

   For example, when the expression `(string-length "abcd")' is read
and evaluated, the sequence of characters `string-length' is read as
the symbol whose name is "string-length".  This symbol is associated
with a variable whose value is the procedure that implements string
length calculation.  Therefore evaluation of the `string-length' symbol
results in that procedure.

   The details of the connection between an unquoted symbol and the
variable to which it refers are explained elsewhere.  See *note Binding
Constructs::, for how associations between symbols and variables are
created, and *note Modules::, for how those associations are affected by
Guile's module system.


File: guile.info,  Node: Symbol Primitives,  Next: Symbol Props,  Prev: Symbol Variables,  Up: Symbols

6.6.7.4 Operations Related to Symbols
.....................................

Given any Scheme value, you can determine whether it is a symbol using
the `symbol?' primitive:

 -- Scheme Procedure: symbol? obj
 -- C Function: scm_symbol_p (obj)
     Return `#t' if OBJ is a symbol, otherwise return `#f'.

 -- C Function: int scm_is_symbol (SCM val)
     Equivalent to `scm_is_true (scm_symbol_p (val))'.

   Once you know that you have a symbol, you can obtain its name as a
string by calling `symbol->string'.  Note that Guile differs by default
from R5RS on the details of `symbol->string' as regards
case-sensitivity:

 -- Scheme Procedure: symbol->string s
 -- C Function: scm_symbol_to_string (s)
     Return the name of symbol S as a string.  By default, Guile reads
     symbols case-sensitively, so the string returned will have the
     same case variation as the sequence of characters that caused S to
     be created.

     If Guile is set to read symbols case-insensitively (as specified by
     R5RS), and S comes into being as part of a literal expression
     (*note Literal expressions: (r5rs)Literal expressions.) or by a
     call to the `read' or `string-ci->symbol' procedures, Guile
     converts any alphabetic characters in the symbol's name to lower
     case before creating the symbol object, so the string returned
     here will be in lower case.

     If S was created by `string->symbol', the case of characters in
     the string returned will be the same as that in the string that was
     passed to `string->symbol', regardless of Guile's case-sensitivity
     setting at the time S was created.

     It is an error to apply mutation procedures like `string-set!' to
     strings returned by this procedure.

   Most symbols are created by writing them literally in code.  However
it is also possible to create symbols programmatically using the
following procedures:

 -- Scheme Procedure: symbol char...
     Return a newly allocated symbol made from the given character
     arguments.

          (symbol #\x #\y #\z) => xyz

 -- Scheme Procedure: list->symbol lst
     Return a newly allocated symbol made from a list of characters.

          (list->symbol '(#\a #\b #\c)) => abc

 -- Scheme Procedure: symbol-append arg ...
     Return a newly allocated symbol whose characters form the
     concatenation of the given symbols, ARG ....

          (let ((h 'hello))
            (symbol-append h 'world))
          => helloworld

 -- Scheme Procedure: string->symbol string
 -- C Function: scm_string_to_symbol (string)
     Return the symbol whose name is STRING.  This procedure can create
     symbols with names containing special characters or letters in the
     non-standard case, but it is usually a bad idea to create such
     symbols because in some implementations of Scheme they cannot be
     read as themselves.

 -- Scheme Procedure: string-ci->symbol str
 -- C Function: scm_string_ci_to_symbol (str)
     Return the symbol whose name is STR.  If Guile is currently
     reading symbols case-insensitively, STR is converted to lowercase
     before the returned symbol is looked up or created.

   The following examples illustrate Guile's detailed behaviour as
regards the case-sensitivity of symbols:

     (read-enable 'case-insensitive)   ; R5RS compliant behaviour

     (symbol->string 'flying-fish)    => "flying-fish"
     (symbol->string 'Martin)         => "martin"
     (symbol->string
        (string->symbol "Malvina"))   => "Malvina"

     (eq? 'mISSISSIppi 'mississippi)  => #t
     (string->symbol "mISSISSIppi")   => mISSISSIppi
     (eq? 'bitBlt (string->symbol "bitBlt")) => #f
     (eq? 'LolliPop
       (string->symbol (symbol->string 'LolliPop))) => #t
     (string=? "K. Harper, M.D."
       (symbol->string
         (string->symbol "K. Harper, M.D."))) => #t

     (read-disable 'case-insensitive)   ; Guile default behaviour

     (symbol->string 'flying-fish)    => "flying-fish"
     (symbol->string 'Martin)         => "Martin"
     (symbol->string
        (string->symbol "Malvina"))   => "Malvina"

     (eq? 'mISSISSIppi 'mississippi)  => #f
     (string->symbol "mISSISSIppi")   => mISSISSIppi
     (eq? 'bitBlt (string->symbol "bitBlt")) => #t
     (eq? 'LolliPop
       (string->symbol (symbol->string 'LolliPop))) => #t
     (string=? "K. Harper, M.D."
       (symbol->string
         (string->symbol "K. Harper, M.D."))) => #t

   From C, there are lower level functions that construct a Scheme
symbol from a C string in the current locale encoding.

   When you want to do more from C, you should convert between symbols
and strings using `scm_symbol_to_string' and `scm_string_to_symbol' and
work with the strings.

 -- C Function: SCM scm_from_latin1_symbol (const char *name)
 -- C Function: SCM scm_from_utf8_symbol (const char *name)
     Construct and return a Scheme symbol whose name is specified by the
     null-terminated C string NAME.  These are appropriate when the C
     string is hard-coded in the source code.

 -- C Function: SCM scm_from_locale_symbol (const char *name)
 -- C Function: SCM scm_from_locale_symboln (const char *name, size_t
          len)
     Construct and return a Scheme symbol whose name is specified by
     NAME.  For `scm_from_locale_symbol', NAME must be null terminated;
     for `scm_from_locale_symboln' the length of NAME is specified
     explicitly by LEN.

     Note that these functions should _not_ be used when NAME is a C
     string constant, because there is no guarantee that the current
     locale will match that of the execution character set, used for
     string and character constants.  Most modern C compilers use UTF-8
     by default, so in such cases we recommend `scm_from_utf8_symbol'.

 -- C Function: SCM scm_take_locale_symbol (char *str)
 -- C Function: SCM scm_take_locale_symboln (char *str, size_t len)
     Like `scm_from_locale_symbol' and `scm_from_locale_symboln',
     respectively, but also frees STR with `free' eventually.  Thus,
     you can use this function when you would free STR anyway
     immediately after creating the Scheme string.  In certain cases,
     Guile can then use STR directly as its internal representation.

   The size of a symbol can also be obtained from C:

 -- C Function: size_t scm_c_symbol_length (SCM sym)
     Return the number of characters in SYM.

   Finally, some applications, especially those that generate new Scheme
code dynamically, need to generate symbols for use in the generated
code.  The `gensym' primitive meets this need:

 -- Scheme Procedure: gensym [prefix]
 -- C Function: scm_gensym (prefix)
     Create a new symbol with a name constructed from a prefix and a
     counter value.  The string PREFIX can be specified as an optional
     argument.  Default prefix is ` g'.  The counter is increased by 1
     at each call.  There is no provision for resetting the counter.

   The symbols generated by `gensym' are _likely_ to be unique, since
their names begin with a space and it is only otherwise possible to
generate such symbols if a programmer goes out of their way to do so.
Uniqueness can be guaranteed by instead using uninterned symbols (*note
Symbol Uninterned::), though they can't be usefully written out and
read back in.


File: guile.info,  Node: Symbol Props,  Next: Symbol Read Syntax,  Prev: Symbol Primitives,  Up: Symbols

6.6.7.5 Function Slots and Property Lists
.........................................

In traditional Lisp dialects, symbols are often understood as having
three kinds of value at once:

   * a "variable" value, which is used when the symbol appears in code
     in a variable reference context

   * a "function" value, which is used when the symbol appears in code
     in a function name position (i.e. as the first element in an
     unquoted list)

   * a "property list" value, which is used when the symbol is given as
     the first argument to Lisp's `put' or `get' functions.

   Although Scheme (as one of its simplifications with respect to Lisp)
does away with the distinction between variable and function namespaces,
Guile currently retains some elements of the traditional structure in
case they turn out to be useful when implementing translators for other
languages, in particular Emacs Lisp.

   Specifically, Guile symbols have two extra slots, one for a symbol's
property list, and one for its "function value."  The following
procedures are provided to access these slots.

 -- Scheme Procedure: symbol-fref symbol
 -- C Function: scm_symbol_fref (symbol)
     Return the contents of SYMBOL's "function slot".

 -- Scheme Procedure: symbol-fset! symbol value
 -- C Function: scm_symbol_fset_x (symbol, value)
     Set the contents of SYMBOL's function slot to VALUE.

 -- Scheme Procedure: symbol-pref symbol
 -- C Function: scm_symbol_pref (symbol)
     Return the "property list" currently associated with SYMBOL.

 -- Scheme Procedure: symbol-pset! symbol value
 -- C Function: scm_symbol_pset_x (symbol, value)
     Set SYMBOL's property list to VALUE.

 -- Scheme Procedure: symbol-property sym prop
     From SYM's property list, return the value for property PROP.  The
     assumption is that SYM's property list is an association list
     whose keys are distinguished from each other using `equal?'; PROP
     should be one of the keys in that list.  If the property list has
     no entry for PROP, `symbol-property' returns `#f'.

 -- Scheme Procedure: set-symbol-property! sym prop val
     In SYM's property list, set the value for property PROP to VAL, or
     add a new entry for PROP, with value VAL, if none already exists.
     For the structure of the property list, see `symbol-property'.

 -- Scheme Procedure: symbol-property-remove! sym prop
     From SYM's property list, remove the entry for property PROP, if
     there is one.  For the structure of the property list, see
     `symbol-property'.

   Support for these extra slots may be removed in a future release,
and it is probably better to avoid using them.  For a more modern and
Schemely approach to properties, see *note Object Properties::.


File: guile.info,  Node: Symbol Read Syntax,  Next: Symbol Uninterned,  Prev: Symbol Props,  Up: Symbols

6.6.7.6 Extended Read Syntax for Symbols
........................................

The read syntax for a symbol is a sequence of letters, digits, and
"extended alphabetic characters", beginning with a character that
cannot begin a number.  In addition, the special cases of `+', `-', and
`...' are read as symbols even though numbers can begin with `+', `-'
or `.'.

   Extended alphabetic characters may be used within identifiers as if
they were letters.  The set of extended alphabetic characters is:

     ! $ % & * + - . / : < = > ? @ ^ _ ~

   In addition to the standard read syntax defined above (which is taken
from R5RS (*note Formal syntax: (r5rs)Formal syntax.)), Guile provides
an extended symbol read syntax that allows the inclusion of unusual
characters such as space characters, newlines and parentheses.  If (for
whatever reason) you need to write a symbol containing characters not
mentioned above, you can do so as follows.

   * Begin the symbol with the characters `#{',

   * write the characters of the symbol and

   * finish the symbol with the characters `}#'.

   Here are a few examples of this form of read syntax.  The first
symbol needs to use extended syntax because it contains a space
character, the second because it contains a line break, and the last
because it looks like a number.

     #{foo bar}#

     #{what
     ever}#

     #{4242}#

   Although Guile provides this extended read syntax for symbols,
widespread usage of it is discouraged because it is not portable and not
very readable.


File: guile.info,  Node: Symbol Uninterned,  Prev: Symbol Read Syntax,  Up: Symbols

6.6.7.7 Uninterned Symbols
..........................

What makes symbols useful is that they are automatically kept unique.
There are no two symbols that are distinct objects but have the same
name.  But of course, there is no rule without exception.  In addition
to the normal symbols that have been discussed up to now, you can also
create special "uninterned" symbols that behave slightly differently.

   To understand what is different about them and why they might be
useful, we look at how normal symbols are actually kept unique.

   Whenever Guile wants to find the symbol with a specific name, for
example during `read' or when executing `string->symbol', it first
looks into a table of all existing symbols to find out whether a symbol
with the given name already exists.  When this is the case, Guile just
returns that symbol.  When not, a new symbol with the name is created
and entered into the table so that it can be found later.

   Sometimes you might want to create a symbol that is guaranteed
`fresh', i.e. a symbol that did not exist previously.  You might also
want to somehow guarantee that no one else will ever unintentionally
stumble across your symbol in the future.  These properties of a symbol
are often needed when generating code during macro expansion.  When
introducing new temporary variables, you want to guarantee that they
don't conflict with variables in other people's code.

   The simplest way to arrange for this is to create a new symbol but
not enter it into the global table of all symbols.  That way, no one
will ever get access to your symbol by chance.  Symbols that are not in
the table are called "uninterned".  Of course, symbols that _are_ in
the table are called "interned".

   You create new uninterned symbols with the function `make-symbol'.
You can test whether a symbol is interned or not with
`symbol-interned?'.

   Uninterned symbols break the rule that the name of a symbol uniquely
identifies the symbol object.  Because of this, they can not be written
out and read back in like interned symbols.  Currently, Guile has no
support for reading uninterned symbols.  Note that the function
`gensym' does not return uninterned symbols for this reason.

 -- Scheme Procedure: make-symbol name
 -- C Function: scm_make_symbol (name)
     Return a new uninterned symbol with the name NAME.  The returned
     symbol is guaranteed to be unique and future calls to
     `string->symbol' will not return it.

 -- Scheme Procedure: symbol-interned? symbol
 -- C Function: scm_symbol_interned_p (symbol)
     Return `#t' if SYMBOL is interned, otherwise return `#f'.

   For example:

     (define foo-1 (string->symbol "foo"))
     (define foo-2 (string->symbol "foo"))
     (define foo-3 (make-symbol "foo"))
     (define foo-4 (make-symbol "foo"))

     (eq? foo-1 foo-2)
     => #t
     ; Two interned symbols with the same name are the same object,

     (eq? foo-1 foo-3)
     => #f
     ; but a call to make-symbol with the same name returns a
     ; distinct object.

     (eq? foo-3 foo-4)
     => #f
     ; A call to make-symbol always returns a new object, even for
     ; the same name.

     foo-3
     => #<uninterned-symbol foo 8085290>
     ; Uninterned symbols print differently from interned symbols,

     (symbol? foo-3)
     => #t
     ; but they are still symbols,

     (symbol-interned? foo-3)
     => #f
     ; just not interned.


File: guile.info,  Node: Keywords,  Next: Other Types,  Prev: Symbols,  Up: Simple Data Types

6.6.8 Keywords
--------------

Keywords are self-evaluating objects with a convenient read syntax that
makes them easy to type.

   Guile's keyword support conforms to R5RS, and adds a (switchable)
read syntax extension to permit keywords to begin with `:' as well as
`#:', or to end with `:'.

* Menu:

* Why Use Keywords?::           Motivation for keyword usage.
* Coding With Keywords::        How to use keywords.
* Keyword Read Syntax::         Read syntax for keywords.
* Keyword Procedures::          Procedures for dealing with keywords.


File: guile.info,  Node: Why Use Keywords?,  Next: Coding With Keywords,  Up: Keywords

6.6.8.1 Why Use Keywords?
.........................

Keywords are useful in contexts where a program or procedure wants to be
able to accept a large number of optional arguments without making its
interface unmanageable.

   To illustrate this, consider a hypothetical `make-window' procedure,
which creates a new window on the screen for drawing into using some
graphical toolkit.  There are many parameters that the caller might
like to specify, but which could also be sensibly defaulted, for
example:

   * color depth - Default: the color depth for the screen

   * background color - Default: white

   * width - Default: 600

   * height - Default: 400

   If `make-window' did not use keywords, the caller would have to pass
in a value for each possible argument, remembering the correct argument
order and using a special value to indicate the default value for that
argument:

     (make-window 'default              ;; Color depth
                  'default              ;; Background color
                  800                   ;; Width
                  100                   ;; Height
                  ...)                  ;; More make-window arguments

   With keywords, on the other hand, defaulted arguments are omitted,
and non-default arguments are clearly tagged by the appropriate
keyword.  As a result, the invocation becomes much clearer:

     (make-window #:width 800 #:height 100)

   On the other hand, for a simpler procedure with few arguments, the
use of keywords would be a hindrance rather than a help.  The primitive
procedure `cons', for example, would not be improved if it had to be
invoked as

     (cons #:car x #:cdr y)

   So the decision whether to use keywords or not is purely pragmatic:
use them if they will clarify the procedure invocation at point of call.


File: guile.info,  Node: Coding With Keywords,  Next: Keyword Read Syntax,  Prev: Why Use Keywords?,  Up: Keywords

6.6.8.2 Coding With Keywords
............................

If a procedure wants to support keywords, it should take a rest argument
and then use whatever means is convenient to extract keywords and their
corresponding arguments from the contents of that rest argument.

   The following example illustrates the principle: the code for
`make-window' uses a helper procedure called `get-keyword-value' to
extract individual keyword arguments from the rest argument.

     (define (get-keyword-value args keyword default)
       (let ((kv (memq keyword args)))
         (if (and kv (>= (length kv) 2))
             (cadr kv)
             default)))

     (define (make-window . args)
       (let ((depth  (get-keyword-value args #:depth  screen-depth))
             (bg     (get-keyword-value args #:bg     "white"))
             (width  (get-keyword-value args #:width  800))
             (height (get-keyword-value args #:height 100))
             ...)
         ...))

   But you don't need to write `get-keyword-value'.  The `(ice-9
optargs)' module provides a set of powerful macros that you can use to
implement keyword-supporting procedures like this:

     (use-modules (ice-9 optargs))

     (define (make-window . args)
       (let-keywords args #f ((depth  screen-depth)
                              (bg     "white")
                              (width  800)
                              (height 100))
         ...))

Or, even more economically, like this:

     (use-modules (ice-9 optargs))

     (define* (make-window #:key (depth  screen-depth)
                                 (bg     "white")
                                 (width  800)
                                 (height 100))
       ...)

   For further details on `let-keywords', `define*' and other
facilities provided by the `(ice-9 optargs)' module, see *note Optional
Arguments::.

   To handle keyword arguments from procedures implemented in C, use
`scm_c_bind_keyword_arguments' (*note Keyword Procedures::).


File: guile.info,  Node: Keyword Read Syntax,  Next: Keyword Procedures,  Prev: Coding With Keywords,  Up: Keywords

6.6.8.3 Keyword Read Syntax
...........................

Guile, by default, only recognizes a keyword syntax that is compatible
with R5RS.  A token of the form `#:NAME', where `NAME' has the same
syntax as a Scheme symbol (*note Symbol Read Syntax::), is the external
representation of the keyword named `NAME'.  Keyword objects print
using this syntax as well, so values containing keyword objects can be
read back into Guile.  When used in an expression, keywords are
self-quoting objects.

   If the `keyword' read option is set to `'prefix', Guile also
recognizes the alternative read syntax `:NAME'.  Otherwise, tokens of
the form `:NAME' are read as symbols, as required by R5RS.

   If the `keyword' read option is set to `'postfix', Guile recognizes
the SRFI-88 read syntax `NAME:' (*note SRFI-88::).  Otherwise, tokens
of this form are read as symbols.

   To enable and disable the alternative non-R5RS keyword syntax, you
use the `read-set!' procedure documented *note Scheme Read::.  Note that
the `prefix' and `postfix' syntax are mutually exclusive.

     (read-set! keywords 'prefix)

     #:type
     =>
     #:type

     :type
     =>
     #:type

     (read-set! keywords 'postfix)

     type:
     =>
     #:type

     :type
     =>
     :type

     (read-set! keywords #f)

     #:type
     =>
     #:type

     :type
     -|
     ERROR: In expression :type:
     ERROR: Unbound variable: :type
     ABORT: (unbound-variable)


File: guile.info,  Node: Keyword Procedures,  Prev: Keyword Read Syntax,  Up: Keywords

6.6.8.4 Keyword Procedures
..........................

 -- Scheme Procedure: keyword? obj
 -- C Function: scm_keyword_p (obj)
     Return `#t' if the argument OBJ is a keyword, else `#f'.

 -- Scheme Procedure: keyword->symbol keyword
 -- C Function: scm_keyword_to_symbol (keyword)
     Return the symbol with the same name as KEYWORD.

 -- Scheme Procedure: symbol->keyword symbol
 -- C Function: scm_symbol_to_keyword (symbol)
     Return the keyword with the same name as SYMBOL.

 -- C Function: int scm_is_keyword (SCM obj)
     Equivalent to `scm_is_true (scm_keyword_p (OBJ))'.

 -- C Function: SCM scm_from_locale_keyword (const char *name)
 -- C Function: SCM scm_from_locale_keywordn (const char *name, size_t
          len)
     Equivalent to `scm_symbol_to_keyword (scm_from_locale_symbol
     (NAME))' and `scm_symbol_to_keyword (scm_from_locale_symboln
     (NAME, LEN))', respectively.

     Note that these functions should _not_ be used when NAME is a C
     string constant, because there is no guarantee that the current
     locale will match that of the execution character set, used for
     string and character constants.  Most modern C compilers use UTF-8
     by default, so in such cases we recommend `scm_from_utf8_keyword'.

 -- C Function: SCM scm_from_latin1_keyword (const char *name)
 -- C Function: SCM scm_from_utf8_keyword (const char *name)
     Equivalent to `scm_symbol_to_keyword (scm_from_latin1_symbol
     (NAME))' and `scm_symbol_to_keyword (scm_from_utf8_symbol
     (NAME))', respectively.

 -- C Function: void scm_c_bind_keyword_arguments (const char *subr,
          SCM rest, scm_t_keyword_arguments_flags flags, SCM keyword1,
          SCM *argp1, ..., SCM keywordN, SCM *argpN, SCM_UNDEFINED)
     Extract the specified keyword arguments from REST, which is not
     modified.  If the keyword argument KEYWORD1 is present in REST
     with an associated value, that value is stored in the variable
     pointed to by ARGP1, otherwise the variable is left unchanged.
     Similarly for the other keywords and argument pointers up to
     KEYWORDN and ARGPN.  The argument list to
     `scm_c_bind_keyword_arguments' must be terminated by
     `SCM_UNDEFINED'.

     Note that since the variables pointed to by ARGP1 through ARGPN
     are left unchanged if the associated keyword argument is not
     present, they should be initialized to their default values before
     calling `scm_c_bind_keyword_arguments'.  Alternatively, you can
     initialize them to `SCM_UNDEFINED' before the call, and then use
     `SCM_UNBNDP' after the call to see which ones were provided.

     If an unrecognized keyword argument is present in REST and FLAGS
     does not contain `SCM_ALLOW_OTHER_KEYS', or if non-keyword
     arguments are present and FLAGS does not contain
     `SCM_ALLOW_NON_KEYWORD_ARGUMENTS', an exception is raised.  SUBR
     should be the name of the procedure receiving the keyword
     arguments, for purposes of error reporting.

     For example:

          SCM k_delimiter;
          SCM k_grammar;
          SCM sym_infix;

          SCM my_string_join (SCM strings, SCM rest)
          {
            SCM delimiter = SCM_UNDEFINED;
            SCM grammar   = sym_infix;

            scm_c_bind_keyword_arguments ("my-string-join", rest, 0,
                                          k_delimiter, &delimiter,
                                          k_grammar, &grammar,
                                          SCM_UNDEFINED);

            if (SCM_UNBNDP (delimiter))
              delimiter = scm_from_utf8_string (" ");

            return scm_string_join (strings, delimiter, grammar);
          }

          void my_init ()
          {
            k_delimiter = scm_from_utf8_keyword ("delimiter");
            k_grammar   = scm_from_utf8_keyword ("grammar");
            sym_infix   = scm_from_utf8_symbol  ("infix");
            scm_c_define_gsubr ("my-string-join", 1, 0, 1, my_string_join);
          }


File: guile.info,  Node: Other Types,  Prev: Keywords,  Up: Simple Data Types

6.6.9 "Functionality-Centric" Data Types
----------------------------------------

Procedures and macros are documented in their own sections: see *note
Procedures:: and *note Macros::.

   Variable objects are documented as part of the description of Guile's
module system: see *note Variables::.

   Asyncs, dynamic roots and fluids are described in the section on
scheduling: see *note Scheduling::.

   Hooks are documented in the section on general utility functions: see
*note Hooks::.

   Ports are described in the section on I/O: see *note Input and
Output::.

   Regular expressions are described in their own section: see *note
Regular Expressions::.


File: guile.info,  Node: Compound Data Types,  Next: Smobs,  Prev: Simple Data Types,  Up: API Reference

6.7 Compound Data Types
=======================

This chapter describes Guile's compound data types.  By "compound" we
mean that the primary purpose of these data types is to act as
containers for other kinds of data (including other compound objects).
For instance, a (non-uniform) vector with length 5 is a container that
can hold five arbitrary Scheme objects.

   The various kinds of container object differ from each other in how
their memory is allocated, how they are indexed, and how particular
values can be looked up within them.

* Menu:

* Pairs::                       Scheme's basic building block.
* Lists::                       Special list functions supported by Guile.
* Vectors::                     One-dimensional arrays of Scheme objects.
* Bit Vectors::                 Vectors of bits.
* Arrays::                      Matrices, etc.
* VLists::                      Vector-like lists.
* Record Overview::             Walking through the maze of record APIs.
* SRFI-9 Records::              The standard, recommended record API.
* Records::                     Guile's historical record API.
* Structures::                  Low-level record representation.
* Dictionary Types::            About dictionary types in general.
* Association Lists::           List-based dictionaries.
* VHashes::                     VList-based dictionaries.
* Hash Tables::                 Table-based dictionaries.


File: guile.info,  Node: Pairs,  Next: Lists,  Up: Compound Data Types

6.7.1 Pairs
-----------

Pairs are used to combine two Scheme objects into one compound object.
Hence the name: A pair stores a pair of objects.

   The data type "pair" is extremely important in Scheme, just like in
any other Lisp dialect.  The reason is that pairs are not only used to
make two values available as one object, but that pairs are used for
constructing lists of values.  Because lists are so important in Scheme,
they are described in a section of their own (*note Lists::).

   Pairs can literally get entered in source code or at the REPL, in the
so-called "dotted list" syntax.  This syntax consists of an opening
parentheses, the first element of the pair, a dot, the second element
and a closing parentheses.  The following example shows how a pair
consisting of the two numbers 1 and 2, and a pair containing the symbols
`foo' and `bar' can be entered.  It is very important to write the
whitespace before and after the dot, because otherwise the Scheme
parser would not be able to figure out where to split the tokens.

     (1 . 2)
     (foo . bar)

   But beware, if you want to try out these examples, you have to
"quote" the expressions.  More information about quotation is available
in the section *note Expression Syntax::.  The correct way to try these
examples is as follows.

     '(1 . 2)
     =>
     (1 . 2)
     '(foo . bar)
     =>
     (foo . bar)

   A new pair is made by calling the procedure `cons' with two
arguments.  Then the argument values are stored into a newly allocated
pair, and the pair is returned.  The name `cons' stands for
"construct".  Use the procedure `pair?' to test whether a given Scheme
object is a pair or not.

 -- Scheme Procedure: cons x y
 -- C Function: scm_cons (x, y)
     Return a newly allocated pair whose car is X and whose cdr is Y.
     The pair is guaranteed to be different (in the sense of `eq?')
     from every previously existing object.

 -- Scheme Procedure: pair? x
 -- C Function: scm_pair_p (x)
     Return `#t' if X is a pair; otherwise return `#f'.

 -- C Function: int scm_is_pair (SCM x)
     Return 1 when X is a pair; otherwise return 0.

   The two parts of a pair are traditionally called "car" and "cdr".
They can be retrieved with procedures of the same name (`car' and
`cdr'), and can be modified with the procedures `set-car!' and
`set-cdr!'.

   Since a very common operation in Scheme programs is to access the
car of a car of a pair, or the car of the cdr of a pair, etc., the
procedures called `caar', `cadr' and so on are also predefined.
However, using these procedures is often detrimental to readability, and
error-prone.  Thus, accessing the contents of a list is usually better
achieved using pattern matching techniques (*note Pattern Matching::).

 -- Scheme Procedure: car pair
 -- Scheme Procedure: cdr pair
 -- C Function: scm_car (pair)
 -- C Function: scm_cdr (pair)
     Return the car or the cdr of PAIR, respectively.

 -- C Macro: SCM SCM_CAR (SCM pair)
 -- C Macro: SCM SCM_CDR (SCM pair)
     These two macros are the fastest way to access the car or cdr of a
     pair; they can be thought of as compiling into a single memory
     reference.

     These macros do no checking at all.  The argument PAIR must be a
     valid pair.

 -- Scheme Procedure: cddr pair
 -- Scheme Procedure: cdar pair
 -- Scheme Procedure: cadr pair
 -- Scheme Procedure: caar pair
 -- Scheme Procedure: cdddr pair
 -- Scheme Procedure: cddar pair
 -- Scheme Procedure: cdadr pair
 -- Scheme Procedure: cdaar pair
 -- Scheme Procedure: caddr pair
 -- Scheme Procedure: cadar pair
 -- Scheme Procedure: caadr pair
 -- Scheme Procedure: caaar pair
 -- Scheme Procedure: cddddr pair
 -- Scheme Procedure: cdddar pair
 -- Scheme Procedure: cddadr pair
 -- Scheme Procedure: cddaar pair
 -- Scheme Procedure: cdaddr pair
 -- Scheme Procedure: cdadar pair
 -- Scheme Procedure: cdaadr pair
 -- Scheme Procedure: cdaaar pair
 -- Scheme Procedure: cadddr pair
 -- Scheme Procedure: caddar pair
 -- Scheme Procedure: cadadr pair
 -- Scheme Procedure: cadaar pair
 -- Scheme Procedure: caaddr pair
 -- Scheme Procedure: caadar pair
 -- Scheme Procedure: caaadr pair
 -- Scheme Procedure: caaaar pair
 -- C Function: scm_cddr (pair)
 -- C Function: scm_cdar (pair)
 -- C Function: scm_cadr (pair)
 -- C Function: scm_caar (pair)
 -- C Function: scm_cdddr (pair)
 -- C Function: scm_cddar (pair)
 -- C Function: scm_cdadr (pair)
 -- C Function: scm_cdaar (pair)
 -- C Function: scm_caddr (pair)
 -- C Function: scm_cadar (pair)
 -- C Function: scm_caadr (pair)
 -- C Function: scm_caaar (pair)
 -- C Function: scm_cddddr (pair)
 -- C Function: scm_cdddar (pair)
 -- C Function: scm_cddadr (pair)
 -- C Function: scm_cddaar (pair)
 -- C Function: scm_cdaddr (pair)
 -- C Function: scm_cdadar (pair)
 -- C Function: scm_cdaadr (pair)
 -- C Function: scm_cdaaar (pair)
 -- C Function: scm_cadddr (pair)
 -- C Function: scm_caddar (pair)
 -- C Function: scm_cadadr (pair)
 -- C Function: scm_cadaar (pair)
 -- C Function: scm_caaddr (pair)
 -- C Function: scm_caadar (pair)
 -- C Function: scm_caaadr (pair)
 -- C Function: scm_caaaar (pair)
     These procedures are compositions of `car' and `cdr', where for
     example `caddr' could be defined by

          (define caddr (lambda (x) (car (cdr (cdr x)))))

     `cadr', `caddr' and `cadddr' pick out the second, third or fourth
     elements of a list, respectively.  SRFI-1 provides the same under
     the names `second', `third' and `fourth' (*note SRFI-1
     Selectors::).

 -- Scheme Procedure: set-car! pair value
 -- C Function: scm_set_car_x (pair, value)
     Stores VALUE in the car field of PAIR.  The value returned by
     `set-car!' is unspecified.

 -- Scheme Procedure: set-cdr! pair value
 -- C Function: scm_set_cdr_x (pair, value)
     Stores VALUE in the cdr field of PAIR.  The value returned by
     `set-cdr!' is unspecified.


File: guile.info,  Node: Lists,  Next: Vectors,  Prev: Pairs,  Up: Compound Data Types

6.7.2 Lists
-----------

A very important data type in Scheme--as well as in all other Lisp
dialects--is the data type "list".(1)

   This is the short definition of what a list is:

   * Either the empty list `()',

   * or a pair which has a list in its cdr.

* Menu:

* List Syntax::                 Writing literal lists.
* List Predicates::             Testing lists.
* List Constructors::           Creating new lists.
* List Selection::              Selecting from lists, getting their length.
* Append/Reverse::              Appending and reversing lists.
* List Modification::           Modifying existing lists.
* List Searching::              Searching for list elements
* List Mapping::                Applying procedures to lists.

   ---------- Footnotes ----------

   (1) Strictly speaking, Scheme does not have a real datatype "list".
Lists are made up of "chained pairs", and only exist by definition--a
list is a chain of pairs which looks like a list.


File: guile.info,  Node: List Syntax,  Next: List Predicates,  Up: Lists

6.7.2.1 List Read Syntax
........................

The syntax for lists is an opening parentheses, then all the elements of
the list (separated by whitespace) and finally a closing
parentheses.(1).

     (1 2 3)            ; a list of the numbers 1, 2 and 3
     ("foo" bar 3.1415) ; a string, a symbol and a real number
     ()                 ; the empty list

   The last example needs a bit more explanation.  A list with no
elements, called the "empty list", is special in some ways.  It is used
for terminating lists by storing it into the cdr of the last pair that
makes up a list.  An example will clear that up:

     (car '(1))
     =>
     1
     (cdr '(1))
     =>
     ()

   This example also shows that lists have to be quoted when written
(*note Expression Syntax::), because they would otherwise be
mistakingly taken as procedure applications (*note Simple Invocation::).

   ---------- Footnotes ----------

   (1) Note that there is no separation character between the list
elements, like a comma or a semicolon.


File: guile.info,  Node: List Predicates,  Next: List Constructors,  Prev: List Syntax,  Up: Lists

6.7.2.2 List Predicates
.......................

Often it is useful to test whether a given Scheme object is a list or
not.  List-processing procedures could use this information to test
whether their input is valid, or they could do different things
depending on the datatype of their arguments.

 -- Scheme Procedure: list? x
 -- C Function: scm_list_p (x)
     Return `#t' if X is a proper list, else `#f'.

   The predicate `null?' is often used in list-processing code to tell
whether a given list has run out of elements.  That is, a loop somehow
deals with the elements of a list until the list satisfies `null?'.
Then, the algorithm terminates.

 -- Scheme Procedure: null? x
 -- C Function: scm_null_p (x)
     Return `#t' if X is the empty list, else `#f'.

 -- C Function: int scm_is_null (SCM x)
     Return 1 when X is the empty list; otherwise return 0.


File: guile.info,  Node: List Constructors,  Next: List Selection,  Prev: List Predicates,  Up: Lists

6.7.2.3 List Constructors
.........................

This section describes the procedures for constructing new lists.
`list' simply returns a list where the elements are the arguments,
`cons*' is similar, but the last argument is stored in the cdr of the
last pair of the list.

 -- Scheme Procedure: list elem ...
 -- C Function: scm_list_1 (elem1)
 -- C Function: scm_list_2 (elem1, elem2)
 -- C Function: scm_list_3 (elem1, elem2, elem3)
 -- C Function: scm_list_4 (elem1, elem2, elem3, elem4)
 -- C Function: scm_list_5 (elem1, elem2, elem3, elem4, elem5)
 -- C Function: scm_list_n (elem1, ..., elemN, SCM_UNDEFINED)
     Return a new list containing elements ELEM ....

     `scm_list_n' takes a variable number of arguments, terminated by
     the special `SCM_UNDEFINED'.  That final `SCM_UNDEFINED' is not
     included in the list.  None of ELEM ... can themselves be
     `SCM_UNDEFINED', or `scm_list_n' will terminate at that point.

 -- Scheme Procedure: cons* arg1 arg2 ...
     Like `list', but the last arg provides the tail of the constructed
     list, returning `(cons ARG1 (cons ARG2 (cons ... ARGN)))'.
     Requires at least one argument.  If given one argument, that
     argument is returned as result.  This function is called `list*'
     in some other Schemes and in Common LISP.

 -- Scheme Procedure: list-copy lst
 -- C Function: scm_list_copy (lst)
     Return a (newly-created) copy of LST.

 -- Scheme Procedure: make-list n [init]
     Create a list containing of N elements, where each element is
     initialized to INIT.  INIT defaults to the empty list `()' if not
     given.

   Note that `list-copy' only makes a copy of the pairs which make up
the spine of the lists.  The list elements are not copied, which means
that modifying the elements of the new list also modifies the elements
of the old list.  On the other hand, applying procedures like
`set-cdr!' or `delv!' to the new list will not alter the old list.  If
you also need to copy the list elements (making a deep copy), use the
procedure `copy-tree' (*note Copying::).


File: guile.info,  Node: List Selection,  Next: Append/Reverse,  Prev: List Constructors,  Up: Lists

6.7.2.4 List Selection
......................

These procedures are used to get some information about a list, or to
retrieve one or more elements of a list.

 -- Scheme Procedure: length lst
 -- C Function: scm_length (lst)
     Return the number of elements in list LST.

 -- Scheme Procedure: last-pair lst
 -- C Function: scm_last_pair (lst)
     Return the last pair in LST, signalling an error if LST is
     circular.

 -- Scheme Procedure: list-ref list k
 -- C Function: scm_list_ref (list, k)
     Return the Kth element from LIST.

 -- Scheme Procedure: list-tail lst k
 -- Scheme Procedure: list-cdr-ref lst k
 -- C Function: scm_list_tail (lst, k)
     Return the "tail" of LST beginning with its Kth element.  The
     first element of the list is considered to be element 0.

     `list-tail' and `list-cdr-ref' are identical.  It may help to
     think of `list-cdr-ref' as accessing the Kth cdr of the list, or
     returning the results of cdring K times down LST.

 -- Scheme Procedure: list-head lst k
 -- C Function: scm_list_head (lst, k)
     Copy the first K elements from LST into a new list, and return it.


File: guile.info,  Node: Append/Reverse,  Next: List Modification,  Prev: List Selection,  Up: Lists

6.7.2.5 Append and Reverse
..........................

`append' and `append!' are used to concatenate two or more lists in
order to form a new list.  `reverse' and `reverse!' return lists with
the same elements as their arguments, but in reverse order.  The
procedure variants with an `!' directly modify the pairs which form the
list, whereas the other procedures create new pairs.  This is why you
should be careful when using the side-effecting variants.

 -- Scheme Procedure: append lst ... obj
 -- Scheme Procedure: append
 -- Scheme Procedure: append! lst ... obj
 -- Scheme Procedure: append!
 -- C Function: scm_append (lstlst)
 -- C Function: scm_append_x (lstlst)
     Return a list comprising all the elements of lists LST ...  OBJ.
     If called with no arguments, return the empty list.

          (append '(x) '(y))          =>  (x y)
          (append '(a) '(b c d))      =>  (a b c d)
          (append '(a (b)) '((c)))    =>  (a (b) (c))

     The last argument OBJ may actually be any object; an improper list
     results if the last argument is not a proper list.

          (append '(a b) '(c . d))    =>  (a b c . d)
          (append '() 'a)             =>  a

     `append' doesn't modify the given lists, but the return may share
     structure with the final OBJ.  `append!' modifies the given lists
     to form its return.

     For `scm_append' and `scm_append_x', LSTLST is a list of the list
     operands LST ... OBJ.  That LSTLST itself is not modified or used
     in the return.

 -- Scheme Procedure: reverse lst
 -- Scheme Procedure: reverse! lst [newtail]
 -- C Function: scm_reverse (lst)
 -- C Function: scm_reverse_x (lst, newtail)
     Return a list comprising the elements of LST, in reverse order.

     `reverse' constructs a new list, `reverse!' modifies LST in
     constructing its return.

     For `reverse!', the optional NEWTAIL is appended to the result.
     NEWTAIL isn't reversed, it simply becomes the list tail.  For
     `scm_reverse_x', the NEWTAIL parameter is mandatory, but can be
     `SCM_EOL' if no further tail is required.


File: guile.info,  Node: List Modification,  Next: List Searching,  Prev: Append/Reverse,  Up: Lists

6.7.2.6 List Modification
.........................

The following procedures modify an existing list, either by changing
elements of the list, or by changing the list structure itself.

 -- Scheme Procedure: list-set! list k val
 -- C Function: scm_list_set_x (list, k, val)
     Set the Kth element of LIST to VAL.

 -- Scheme Procedure: list-cdr-set! list k val
 -- C Function: scm_list_cdr_set_x (list, k, val)
     Set the Kth cdr of LIST to VAL.

 -- Scheme Procedure: delq item lst
 -- C Function: scm_delq (item, lst)
     Return a newly-created copy of LST with elements `eq?' to ITEM
     removed.  This procedure mirrors `memq': `delq' compares elements
     of LST against ITEM with `eq?'.

 -- Scheme Procedure: delv item lst
 -- C Function: scm_delv (item, lst)
     Return a newly-created copy of LST with elements `eqv?' to ITEM
     removed.  This procedure mirrors `memv': `delv' compares elements
     of LST against ITEM with `eqv?'.

 -- Scheme Procedure: delete item lst
 -- C Function: scm_delete (item, lst)
     Return a newly-created copy of LST with elements `equal?' to ITEM
     removed.  This procedure mirrors `member': `delete' compares
     elements of LST against ITEM with `equal?'.

     See also SRFI-1 which has an extended `delete' (*note SRFI-1
     Deleting::), and also an `lset-difference' which can delete
     multiple ITEMs in one call (*note SRFI-1 Set Operations::).

 -- Scheme Procedure: delq! item lst
 -- Scheme Procedure: delv! item lst
 -- Scheme Procedure: delete! item lst
 -- C Function: scm_delq_x (item, lst)
 -- C Function: scm_delv_x (item, lst)
 -- C Function: scm_delete_x (item, lst)
     These procedures are destructive versions of `delq', `delv' and
     `delete': they modify the pointers in the existing LST rather than
     creating a new list.  Caveat evaluator: Like other destructive
     list functions, these functions cannot modify the binding of LST,
     and so cannot be used to delete the first element of LST
     destructively.

 -- Scheme Procedure: delq1! item lst
 -- C Function: scm_delq1_x (item, lst)
     Like `delq!', but only deletes the first occurrence of ITEM from
     LST.  Tests for equality using `eq?'.  See also `delv1!' and
     `delete1!'.

 -- Scheme Procedure: delv1! item lst
 -- C Function: scm_delv1_x (item, lst)
     Like `delv!', but only deletes the first occurrence of ITEM from
     LST.  Tests for equality using `eqv?'.  See also `delq1!' and
     `delete1!'.

 -- Scheme Procedure: delete1! item lst
 -- C Function: scm_delete1_x (item, lst)
     Like `delete!', but only deletes the first occurrence of ITEM from
     LST.  Tests for equality using `equal?'.  See also `delq1!' and
     `delv1!'.

 -- Scheme Procedure: filter pred lst
 -- Scheme Procedure: filter! pred lst
     Return a list containing all elements from LST which satisfy the
     predicate PRED.  The elements in the result list have the same
     order as in LST.  The order in which PRED is applied to the list
     elements is not specified.

     `filter' does not change LST, but the result may share a tail with
     it.  `filter!' may modify LST to construct its return.


File: guile.info,  Node: List Searching,  Next: List Mapping,  Prev: List Modification,  Up: Lists

6.7.2.7 List Searching
......................

The following procedures search lists for particular elements.  They use
different comparison predicates for comparing list elements with the
object to be searched.  When they fail, they return `#f', otherwise
they return the sublist whose car is equal to the search object, where
equality depends on the equality predicate used.

 -- Scheme Procedure: memq x lst
 -- C Function: scm_memq (x, lst)
     Return the first sublist of LST whose car is `eq?' to X where the
     sublists of LST are the non-empty lists returned by `(list-tail
     LST K)' for K less than the length of LST.  If X does not occur in
     LST, then `#f' (not the empty list) is returned.

 -- Scheme Procedure: memv x lst
 -- C Function: scm_memv (x, lst)
     Return the first sublist of LST whose car is `eqv?' to X where the
     sublists of LST are the non-empty lists returned by `(list-tail
     LST K)' for K less than the length of LST.  If X does not occur in
     LST, then `#f' (not the empty list) is returned.

 -- Scheme Procedure: member x lst
 -- C Function: scm_member (x, lst)
     Return the first sublist of LST whose car is `equal?' to X where
     the sublists of LST are the non-empty lists returned by
     `(list-tail LST K)' for K less than the length of LST.  If X does
     not occur in LST, then `#f' (not the empty list) is returned.

     See also SRFI-1 which has an extended `member' function (*note
     SRFI-1 Searching::).


File: guile.info,  Node: List Mapping,  Prev: List Searching,  Up: Lists

6.7.2.8 List Mapping
....................

List processing is very convenient in Scheme because the process of
iterating over the elements of a list can be highly abstracted.  The
procedures in this section are the most basic iterating procedures for
lists.  They take a procedure and one or more lists as arguments, and
apply the procedure to each element of the list.  They differ in their
return value.

 -- Scheme Procedure: map proc arg1 arg2 ...
 -- Scheme Procedure: map-in-order proc arg1 arg2 ...
 -- C Function: scm_map (proc, arg1, args)
     Apply PROC to each element of the list ARG1 (if only two arguments
     are given), or to the corresponding elements of the argument lists
     (if more than two arguments are given).  The result(s) of the
     procedure applications are saved and returned in a list.  For
     `map', the order of procedure applications is not specified,
     `map-in-order' applies the procedure from left to right to the list
     elements.

 -- Scheme Procedure: for-each proc arg1 arg2 ...
     Like `map', but the procedure is always applied from left to right,
     and the result(s) of the procedure applications are thrown away.
     The return value is not specified.

   See also SRFI-1 which extends these functions to take lists of
unequal lengths (*note SRFI-1 Fold and Map::).


File: guile.info,  Node: Vectors,  Next: Bit Vectors,  Prev: Lists,  Up: Compound Data Types

6.7.3 Vectors
-------------

Vectors are sequences of Scheme objects.  Unlike lists, the length of a
vector, once the vector is created, cannot be changed.  The advantage of
vectors over lists is that the time required to access one element of a
vector given its "position" (synonymous with "index"), a zero-origin
number, is constant, whereas lists have an access time linear to the
position of the accessed element in the list.

   Vectors can contain any kind of Scheme object; it is even possible to
have different types of objects in the same vector.  For vectors
containing vectors, you may wish to use arrays, instead.  Note, too,
that vectors are the special case of one dimensional non-uniform arrays
and that most array procedures operate happily on vectors (*note
Arrays::).

* Menu:

* Vector Syntax::               Read syntax for vectors.
* Vector Creation::             Dynamic vector creation and validation.
* Vector Accessors::            Accessing and modifying vector contents.
* Vector Accessing from C::     Ways to work with vectors from C.
* Uniform Numeric Vectors::     Vectors of unboxed numeric values.


File: guile.info,  Node: Vector Syntax,  Next: Vector Creation,  Up: Vectors

6.7.3.1 Read Syntax for Vectors
...............................

Vectors can literally be entered in source code, just like strings,
characters or some of the other data types.  The read syntax for vectors
is as follows: A sharp sign (`#'), followed by an opening parentheses,
all elements of the vector in their respective read syntax, and finally
a closing parentheses.  The following are examples of the read syntax
for vectors; where the first vector only contains numbers and the
second three different object types: a string, a symbol and a number in
hexadecimal notation.

     #(1 2 3)
     #("Hello" foo #xdeadbeef)

   Like lists, vectors have to be quoted:

     '#(a b c) => #(a b c)


File: guile.info,  Node: Vector Creation,  Next: Vector Accessors,  Prev: Vector Syntax,  Up: Vectors

6.7.3.2 Dynamic Vector Creation and Validation
..............................................

Instead of creating a vector implicitly by using the read syntax just
described, you can create a vector dynamically by calling one of the
`vector' and `list->vector' primitives with the list of Scheme values
that you want to place into a vector.  The size of the vector thus
created is determined implicitly by the number of arguments given.

 -- Scheme Procedure: vector arg ...
 -- Scheme Procedure: list->vector l
 -- C Function: scm_vector (l)
     Return a newly allocated vector composed of the given arguments.
     Analogous to `list'.

          (vector 'a 'b 'c) => #(a b c)

   The inverse operation is `vector->list':

 -- Scheme Procedure: vector->list v
 -- C Function: scm_vector_to_list (v)
     Return a newly allocated list composed of the elements of V.

          (vector->list '#(dah dah didah)) =>  (dah dah didah)
          (list->vector '(dididit dah)) =>  #(dididit dah)

   To allocate a vector with an explicitly specified size, use
`make-vector'.  With this primitive you can also specify an initial
value for the vector elements (the same value for all elements, that
is):

 -- Scheme Procedure: make-vector len [fill]
 -- C Function: scm_make_vector (len, fill)
     Return a newly allocated vector of LEN elements.  If a second
     argument is given, then each position is initialized to FILL.
     Otherwise the initial contents of each position is unspecified.

 -- C Function: SCM scm_c_make_vector (size_t k, SCM fill)
     Like `scm_make_vector', but the length is given as a `size_t'.

   To check whether an arbitrary Scheme value _is_ a vector, use the
`vector?' primitive:

 -- Scheme Procedure: vector? obj
 -- C Function: scm_vector_p (obj)
     Return `#t' if OBJ is a vector, otherwise return `#f'.

 -- C Function: int scm_is_vector (SCM obj)
     Return non-zero when OBJ is a vector, otherwise return `zero'.


File: guile.info,  Node: Vector Accessors,  Next: Vector Accessing from C,  Prev: Vector Creation,  Up: Vectors

6.7.3.3 Accessing and Modifying Vector Contents
...............................................

`vector-length' and `vector-ref' return information about a given
vector, respectively its size and the elements that are contained in
the vector.

 -- Scheme Procedure: vector-length vector
 -- C Function: scm_vector_length (vector)
     Return the number of elements in VECTOR as an exact integer.

 -- C Function: size_t scm_c_vector_length (SCM vec)
     Return the number of elements in VEC as a `size_t'.

 -- Scheme Procedure: vector-ref vec k
 -- C Function: scm_vector_ref (vec, k)
     Return the contents of position K of VEC.  K must be a valid index
     of VEC.
          (vector-ref '#(1 1 2 3 5 8 13 21) 5) => 8
          (vector-ref '#(1 1 2 3 5 8 13 21)
              (let ((i (round (* 2 (acos -1)))))
                (if (inexact? i)
                  (inexact->exact i)
                     i))) => 13

 -- C Function: SCM scm_c_vector_ref (SCM vec, size_t k)
     Return the contents of position K (a `size_t') of VEC.

   A vector created by one of the dynamic vector constructor procedures
(*note Vector Creation::) can be modified using the following
procedures.

   _NOTE:_ According to R5RS, it is an error to use any of these
procedures on a literally read vector, because such vectors should be
considered as constants.  Currently, however, Guile does not detect this
error.

 -- Scheme Procedure: vector-set! vec k obj
 -- C Function: scm_vector_set_x (vec, k, obj)
     Store OBJ in position K of VEC.  K must be a valid index of VEC.
     The value returned by `vector-set!' is unspecified.
          (let ((vec (vector 0 '(2 2 2 2) "Anna")))
            (vector-set! vec 1 '("Sue" "Sue"))
            vec) =>  #(0 ("Sue" "Sue") "Anna")

 -- C Function: void scm_c_vector_set_x (SCM vec, size_t k, SCM obj)
     Store OBJ in position K (a `size_t') of VEC.

 -- Scheme Procedure: vector-fill! vec fill
 -- C Function: scm_vector_fill_x (vec, fill)
     Store FILL in every position of VEC.  The value returned by
     `vector-fill!' is unspecified.

 -- Scheme Procedure: vector-copy vec
 -- C Function: scm_vector_copy (vec)
     Return a copy of VEC.

 -- Scheme Procedure: vector-move-left! vec1 start1 end1 vec2 start2
 -- C Function: scm_vector_move_left_x (vec1, start1, end1, vec2,
          start2)
     Copy elements from VEC1, positions START1 to END1, to VEC2
     starting at position START2.  START1 and START2 are inclusive
     indices; END1 is exclusive.

     `vector-move-left!' copies elements in leftmost order.  Therefore,
     in the case where VEC1 and VEC2 refer to the same vector,
     `vector-move-left!' is usually appropriate when START1 is greater
     than START2.

 -- Scheme Procedure: vector-move-right! vec1 start1 end1 vec2 start2
 -- C Function: scm_vector_move_right_x (vec1, start1, end1, vec2,
          start2)
     Copy elements from VEC1, positions START1 to END1, to VEC2
     starting at position START2.  START1 and START2 are inclusive
     indices; END1 is exclusive.

     `vector-move-right!' copies elements in rightmost order.
     Therefore, in the case where VEC1 and VEC2 refer to the same
     vector, `vector-move-right!' is usually appropriate when START1 is
     less than START2.


File: guile.info,  Node: Vector Accessing from C,  Next: Uniform Numeric Vectors,  Prev: Vector Accessors,  Up: Vectors

6.7.3.4 Vector Accessing from C
...............................

A vector can be read and modified from C with the functions
`scm_c_vector_ref' and `scm_c_vector_set_x', for example.  In addition
to these functions, there are two more ways to access vectors from C
that might be more efficient in certain situations: you can restrict
yourself to "simple vectors" and then use the very fast _simple vector
macros_; or you can use the very general framework for accessing all
kinds of arrays (*note Accessing Arrays from C::), which is more
verbose, but can deal efficiently with all kinds of vectors (and
arrays).  For vectors, you can use the `scm_vector_elements' and
`scm_vector_writable_elements' functions as shortcuts.

 -- C Function: int scm_is_simple_vector (SCM obj)
     Return non-zero if OBJ is a simple vector, else return zero.  A
     simple vector is a vector that can be used with the `SCM_SIMPLE_*'
     macros below.

     The following functions are guaranteed to return simple vectors:
     `scm_make_vector', `scm_c_make_vector', `scm_vector',
     `scm_list_to_vector'.

 -- C Macro: size_t SCM_SIMPLE_VECTOR_LENGTH (SCM vec)
     Evaluates to the length of the simple vector VEC.  No type
     checking is done.

 -- C Macro: SCM SCM_SIMPLE_VECTOR_REF (SCM vec, size_t idx)
     Evaluates to the element at position IDX in the simple vector VEC.
     No type or range checking is done.

 -- C Macro: void SCM_SIMPLE_VECTOR_SET (SCM vec, size_t idx, SCM val)
     Sets the element at position IDX in the simple vector VEC to VAL.
     No type or range checking is done.

 -- C Function: const SCM * scm_vector_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
     Acquire a handle for the vector VEC and return a pointer to the
     elements of it.  This pointer can only be used to read the
     elements of VEC.  When VEC is not a vector, an error is signaled.
     The handle must eventually be released with
     `scm_array_handle_release'.

     The variables pointed to by LENP and INCP are filled with the
     number of elements of the vector and the increment (number of
     elements) between successive elements, respectively.  Successive
     elements of VEC need not be contiguous in their underlying "root
     vector" returned here; hence the increment is not necessarily
     equal to 1 and may well be negative too (*note Shared Arrays::).

     The following example shows the typical way to use this function.
     It creates a list of all elements of VEC (in reverse order).

          scm_t_array_handle handle;
          size_t i, len;
          ssize_t inc;
          const SCM *elt;
          SCM list;

          elt = scm_vector_elements (vec, &handle, &len, &inc);
          list = SCM_EOL;
          for (i = 0; i < len; i++, elt += inc)
            list = scm_cons (*elt, list);
          scm_array_handle_release (&handle);


 -- C Function: SCM * scm_vector_writable_elements (SCM vec,
          scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
     Like `scm_vector_elements' but the pointer can be used to modify
     the vector.

     The following example shows the typical way to use this function.
     It fills a vector with `#t'.

          scm_t_array_handle handle;
          size_t i, len;
          ssize_t inc;
          SCM *elt;

          elt = scm_vector_writable_elements (vec, &handle, &len, &inc);
          for (i = 0; i < len; i++, elt += inc)
            *elt = SCM_BOOL_T;
          scm_array_handle_release (&handle);



File: guile.info,  Node: Uniform Numeric Vectors,  Prev: Vector Accessing from C,  Up: Vectors

6.7.3.5 Uniform Numeric Vectors
...............................

A uniform numeric vector is a vector whose elements are all of a single
numeric type.  Guile offers uniform numeric vectors for signed and
unsigned 8-bit, 16-bit, 32-bit, and 64-bit integers, two sizes of
floating point values, and complex floating-point numbers of these two
sizes. *Note SRFI-4::, for more information.

   For many purposes, bytevectors work just as well as uniform vectors,
and have the advantage that they integrate well with binary input and
output.  *Note Bytevectors::, for more information on bytevectors.


File: guile.info,  Node: Bit Vectors,  Next: Arrays,  Prev: Vectors,  Up: Compound Data Types

6.7.4 Bit Vectors
-----------------

Bit vectors are zero-origin, one-dimensional arrays of booleans.  They
are displayed as a sequence of `0's and `1's prefixed by `#*', e.g.,

     (make-bitvector 8 #f) =>
     #*00000000

   Bit vectors are the special case of one dimensional bit arrays, and
can thus be used with the array procedures, *Note Arrays::.

 -- Scheme Procedure: bitvector? obj
 -- C Function: scm_bitvector_p (obj)
     Return `#t' when OBJ is a bitvector, else return `#f'.

 -- C Function: int scm_is_bitvector (SCM obj)
     Return `1' when OBJ is a bitvector, else return `0'.

 -- Scheme Procedure: make-bitvector len [fill]
 -- C Function: scm_make_bitvector (len, fill)
     Create a new bitvector of length LEN and optionally initialize all
     elements to FILL.

 -- C Function: SCM scm_c_make_bitvector (size_t len, SCM fill)
     Like `scm_make_bitvector', but the length is given as a `size_t'.

 -- Scheme Procedure: bitvector bit ...
 -- C Function: scm_bitvector (bits)
     Create a new bitvector with the arguments as elements.

 -- Scheme Procedure: bitvector-length vec
 -- C Function: scm_bitvector_length (vec)
     Return the length of the bitvector VEC.

 -- C Function: size_t scm_c_bitvector_length (SCM vec)
     Like `scm_bitvector_length', but the length is returned as a
     `size_t'.

 -- Scheme Procedure: bitvector-ref vec idx
 -- C Function: scm_bitvector_ref (vec, idx)
     Return the element at index IDX of the bitvector VEC.

 -- C Function: SCM scm_c_bitvector_ref (SCM vec, size_t idx)
     Return the element at index IDX of the bitvector VEC.

 -- Scheme Procedure: bitvector-set! vec idx val
 -- C Function: scm_bitvector_set_x (vec, idx, val)
     Set the element at index IDX of the bitvector VEC when VAL is
     true, else clear it.

 -- C Function: SCM scm_c_bitvector_set_x (SCM vec, size_t idx, SCM val)
     Set the element at index IDX of the bitvector VEC when VAL is
     true, else clear it.

 -- Scheme Procedure: bitvector-fill! vec val
 -- C Function: scm_bitvector_fill_x (vec, val)
     Set all elements of the bitvector VEC when VAL is true, else clear
     them.

 -- Scheme Procedure: list->bitvector list
 -- C Function: scm_list_to_bitvector (list)
     Return a new bitvector initialized with the elements of LIST.

 -- Scheme Procedure: bitvector->list vec
 -- C Function: scm_bitvector_to_list (vec)
     Return a new list initialized with the elements of the bitvector
     VEC.

 -- Scheme Procedure: bit-count bool bitvector
 -- C Function: scm_bit_count (bool, bitvector)
     Return a count of how many entries in BITVECTOR are equal to BOOL.
     For example,

          (bit-count #f #*000111000)  => 6

 -- Scheme Procedure: bit-position bool bitvector start
 -- C Function: scm_bit_position (bool, bitvector, start)
     Return the index of the first occurrence of BOOL in BITVECTOR,
     starting from START.  If there is no BOOL entry between START and
     the end of BITVECTOR, then return `#f'.  For example,

          (bit-position #t #*000101 0)  => 3
          (bit-position #f #*0001111 3) => #f

 -- Scheme Procedure: bit-invert! bitvector
 -- C Function: scm_bit_invert_x (bitvector)
     Modify BITVECTOR by replacing each element with its negation.

 -- Scheme Procedure: bit-set*! bitvector uvec bool
 -- C Function: scm_bit_set_star_x (bitvector, uvec, bool)
     Set entries of BITVECTOR to BOOL, with UVEC selecting the entries
     to change.  The return value is unspecified.

     If UVEC is a bit vector, then those entries where it has `#t' are
     the ones in BITVECTOR which are set to BOOL.  UVEC and BITVECTOR
     must be the same length.  When BOOL is `#t' it's like UVEC is
     OR'ed into BITVECTOR.  Or when BOOL is `#f' it can be seen as an
     ANDNOT.

          (define bv #*01000010)
          (bit-set*! bv #*10010001 #t)
          bv
          => #*11010011

     If UVEC is a uniform vector of unsigned long integers, then
     they're indexes into BITVECTOR which are set to BOOL.

          (define bv #*01000010)
          (bit-set*! bv #u(5 2 7) #t)
          bv
          => #*01100111

 -- Scheme Procedure: bit-count* bitvector uvec bool
 -- C Function: scm_bit_count_star (bitvector, uvec, bool)
     Return a count of how many entries in BITVECTOR are equal to BOOL,
     with UVEC selecting the entries to consider.

     UVEC is interpreted in the same way as for `bit-set*!' above.
     Namely, if UVEC is a bit vector then entries which have `#t' there
     are considered in BITVECTOR.  Or if UVEC is a uniform vector of
     unsigned long integers then it's the indexes in BITVECTOR to
     consider.

     For example,

          (bit-count* #*01110111 #*11001101 #t) => 3
          (bit-count* #*01110111 #u(7 0 4) #f)  => 2

 -- C Function: const scm_t_uint32 * scm_bitvector_elements (SCM vec,
          scm_t_array_handle *handle, size_t *offp, size_t *lenp,
          ssize_t *incp)
     Like `scm_vector_elements' (*note Vector Accessing from C::), but
     for bitvectors.  The variable pointed to by OFFP is set to the
     value returned by `scm_array_handle_bit_elements_offset'.  See
     `scm_array_handle_bit_elements' for how to use the returned
     pointer and the offset.

 -- C Function: scm_t_uint32 * scm_bitvector_writable_elements (SCM
          vec, scm_t_array_handle *handle, size_t *offp, size_t *lenp,
          ssize_t *incp)
     Like `scm_bitvector_elements', but the pointer is good for reading
     and writing.


File: guile.info,  Node: Arrays,  Next: VLists,  Prev: Bit Vectors,  Up: Compound Data Types

6.7.5 Arrays
------------

"Arrays" are a collection of cells organized into an arbitrary number
of dimensions.  Each cell can be accessed in constant time by supplying
an index for each dimension.

   In the current implementation, an array uses a vector of some kind
for the actual storage of its elements.  Any kind of vector will do, so
you can have arrays of uniform numeric values, arrays of characters,
arrays of bits, and of course, arrays of arbitrary Scheme values.  For
example, arrays with an underlying `c64vector' might be nice for digital
signal processing, while arrays made from a `u8vector' might be used to
hold gray-scale images.

   The number of dimensions of an array is called its "rank".  Thus, a
matrix is an array of rank 2, while a vector has rank 1.  When
accessing an array element, you have to specify one exact integer for
each dimension.  These integers are called the "indices" of the
element.  An array specifies the allowed range of indices for each
dimension via an inclusive lower and upper bound.  These bounds can
well be negative, but the upper bound must be greater than or equal to
the lower bound minus one.  When all lower bounds of an array are zero,
it is called a "zero-origin" array.

   Arrays can be of rank 0, which could be interpreted as a scalar.
Thus, a zero-rank array can store exactly one object and the list of
indices of this element is the empty list.

   Arrays contain zero elements when one of their dimensions has a zero
length.  These empty arrays maintain information about their shape: a
matrix with zero columns and 3 rows is different from a matrix with 3
columns and zero rows, which again is different from a vector of length
zero.

   The array procedures are all polymorphic, treating strings, uniform
numeric vectors, bytevectors, bit vectors and ordinary vectors as one
dimensional arrays.

* Menu:

* Array Syntax::
* Array Procedures::
* Shared Arrays::
* Accessing Arrays from C::


File: guile.info,  Node: Array Syntax,  Next: Array Procedures,  Up: Arrays

6.7.5.1 Array Syntax
....................

An array is displayed as `#' followed by its rank, followed by a tag
that describes the underlying vector, optionally followed by
information about its shape, and finally followed by the cells,
organized into dimensions using parentheses.

   In more words, the array tag is of the form

       #<rank><vectag><@lower><:len><@lower><:len>...

   where `<rank>' is a positive integer in decimal giving the rank of
the array.  It is omitted when the rank is 1 and the array is non-shared
and has zero-origin (see below).  For shared arrays and for a non-zero
origin, the rank is always printed even when it is 1 to distinguish
them from ordinary vectors.

   The `<vectag>' part is the tag for a uniform numeric vector, like
`u8', `s16', etc, `b' for bitvectors, or `a' for strings.  It is empty
for ordinary vectors.

   The `<@lower>' part is a `@' character followed by a signed integer
in decimal giving the lower bound of a dimension.  There is one
`<@lower>' for each dimension.  When all lower bounds are zero, all
`<@lower>' parts are omitted.

   The `<:len>' part is a `:' character followed by an unsigned integer
in decimal giving the length of a dimension.  Like for the lower
bounds, there is one `<:len>' for each dimension, and the `<:len>' part
always follows the `<@lower>' part for a dimension.  Lengths are only
then printed when they can't be deduced from the nested lists of
elements of the array literal, which can happen when at least one
length is zero.

   As a special case, an array of rank 0 is printed as
`#0<vectag>(<scalar>)', where `<scalar>' is the result of printing the
single element of the array.

   Thus,

`#(1 2 3)'
     is an ordinary array of rank 1 with lower bound 0 in dimension 0.
     (I.e., a regular vector.)

`#@2(1 2 3)'
     is an ordinary array of rank 1 with lower bound 2 in dimension 0.

`#2((1 2 3) (4 5 6))'
     is a non-uniform array of rank 2; a 3x3 matrix with index ranges
     0..2 and 0..2.

`#u32(0 1 2)'
     is a uniform u8 array of rank 1.

`#2u32@2@3((1 2) (2 3))'
     is a uniform u8 array of rank 2 with index ranges 2..3 and 3..4.

`#2()'
     is a two-dimensional array with index ranges 0..-1 and 0..-1, i.e.
     both dimensions have length zero.

`#2:0:2()'
     is a two-dimensional array with index ranges 0..-1 and 0..1, i.e.
     the first dimension has length zero, but the second has length 2.

`#0(12)'
     is a rank-zero array with contents 12.


   In addition, bytevectors are also arrays, but use a different syntax
(*note Bytevectors::):

`#vu8(1 2 3)'
     is a 3-byte long bytevector, with contents 1, 2, 3.



File: guile.info,  Node: Array Procedures,  Next: Shared Arrays,  Prev: Array Syntax,  Up: Arrays

6.7.5.2 Array Procedures
........................

When an array is created, the range of each dimension must be
specified, e.g., to create a 2x3 array with a zero-based index:

     (make-array 'ho 2 3) => #2((ho ho ho) (ho ho ho))

   The range of each dimension can also be given explicitly, e.g.,
another way to create the same array:

     (make-array 'ho '(0 1) '(0 2)) => #2((ho ho ho) (ho ho ho))

   The following procedures can be used with arrays (or vectors).  An
argument shown as IDX... means one parameter for each dimension in the
array.  A IDXLIST argument means a list of such values, one for each
dimension.

 -- Scheme Procedure: array? obj
 -- C Function: scm_array_p (obj, unused)
     Return `#t' if the OBJ is an array, and `#f' if not.

     The second argument to scm_array_p is there for historical reasons,
     but it is not used.  You should always pass `SCM_UNDEFINED' as its
     value.

 -- Scheme Procedure: typed-array? obj type
 -- C Function: scm_typed_array_p (obj, type)
     Return `#t' if the OBJ is an array of type TYPE, and `#f' if not.

 -- C Function: int scm_is_array (SCM obj)
     Return `1' if the OBJ is an array and `0' if not.

 -- C Function: int scm_is_typed_array (SCM obj, SCM type)
     Return `0' if the OBJ is an array of type TYPE, and `1' if not.

 -- Scheme Procedure: make-array fill bound ...
 -- C Function: scm_make_array (fill, bounds)
     Equivalent to `(make-typed-array #t FILL BOUND ...)'.

 -- Scheme Procedure: make-typed-array type fill bound ...
 -- C Function: scm_make_typed_array (type, fill, bounds)
     Create and return an array that has as many dimensions as there are
     BOUNDs and (maybe) fill it with FILL.

     The underlying storage vector is created according to TYPE, which
     must be a symbol whose name is the `vectag' of the array as
     explained above, or `#t' for ordinary, non-specialized arrays.

     For example, using the symbol `f64' for TYPE will create an array
     that uses a `f64vector' for storing its elements, and `a' will use
     a string.

     When FILL is not the special _unspecified_ value, the new array is
     filled with FILL.  Otherwise, the initial contents of the array is
     unspecified.  The special _unspecified_ value is stored in the
     variable `*unspecified*' so that for example `(make-typed-array
     'u32 *unspecified* 4)' creates a uninitialized `u32' vector of
     length 4.

     Each BOUND may be a positive non-zero integer N, in which case the
     index for that dimension can range from 0 through N-1; or an
     explicit index range specifier in the form `(LOWER UPPER)', where
     both LOWER and UPPER are integers, possibly less than zero, and
     possibly the same number (however, LOWER cannot be greater than
     UPPER).

 -- Scheme Procedure: list->array dimspec list
     Equivalent to `(list->typed-array #t DIMSPEC LIST)'.

 -- Scheme Procedure: list->typed-array type dimspec list
 -- C Function: scm_list_to_typed_array (type, dimspec, list)
     Return an array of the type indicated by TYPE with elements the
     same as those of LIST.

     The argument DIMSPEC determines the number of dimensions of the
     array and their lower bounds.  When DIMSPEC is an exact integer,
     it gives the number of dimensions directly and all lower bounds are
     zero.  When it is a list of exact integers, then each element is
     the lower index bound of a dimension, and there will be as many
     dimensions as elements in the list.

 -- Scheme Procedure: array-type array
 -- C Function: scm_array_type (array)
     Return the type of ARRAY.  This is the `vectag' used for printing
     ARRAY (or `#t' for ordinary arrays) and can be used with
     `make-typed-array' to create an array of the same kind as ARRAY.

 -- Scheme Procedure: array-ref array idx ...
 -- C Function: scm_array_ref (array, idxlist)
     Return the element at `(idx ...)' in ARRAY.

          (define a (make-array 999 '(1 2) '(3 4)))
          (array-ref a 2 4) => 999

 -- Scheme Procedure: array-in-bounds? array idx ...
 -- C Function: scm_array_in_bounds_p (array, idxlist)
     Return `#t' if the given indices would be acceptable to
     `array-ref'.

          (define a (make-array #f '(1 2) '(3 4)))
          (array-in-bounds? a 2 3) => #t
          (array-in-bounds? a 0 0) => #f

 -- Scheme Procedure: array-set! array obj idx ...
 -- C Function: scm_array_set_x (array, obj, idxlist)
     Set the element at `(idx ...)' in ARRAY to OBJ.  The return value
     is unspecified.

          (define a (make-array #f '(0 1) '(0 1)))
          (array-set! a #t 1 1)
          a => #2((#f #f) (#f #t))

 -- Scheme Procedure: array-shape array
 -- Scheme Procedure: array-dimensions array
 -- C Function: scm_array_dimensions (array)
     Return a list of the bounds for each dimension of ARRAY.

     `array-shape' gives `(LOWER UPPER)' for each dimension.
     `array-dimensions' instead returns just UPPER+1 for dimensions
     with a 0 lower bound.  Both are suitable as input to `make-array'.

     For example,

          (define a (make-array 'foo '(-1 3) 5))
          (array-shape a)      => ((-1 3) (0 4))
          (array-dimensions a) => ((-1 3) 5)

 -- Scheme Procedure: array-length array
 -- C Function: scm_array_length (array)
 -- C Function: size_t scm_c_array_length (array)
     Return the length of an array: its first dimension. It is an error
     to ask for the length of an array of rank 0.

 -- Scheme Procedure: array-rank array
 -- C Function: scm_array_rank (array)
     Return the rank of ARRAY.

 -- C Function: size_t scm_c_array_rank (SCM array)
     Return the rank of ARRAY as a `size_t'.

 -- Scheme Procedure: array->list array
 -- C Function: scm_array_to_list (array)
     Return a list consisting of all the elements, in order, of ARRAY.

 -- Scheme Procedure: array-copy! src dst
 -- Scheme Procedure: array-copy-in-order! src dst
 -- C Function: scm_array_copy_x (src, dst)
     Copy every element from vector or array SRC to the corresponding
     element of DST.  DST must have the same rank as SRC, and be at
     least as large in each dimension.  The return value is unspecified.

 -- Scheme Procedure: array-fill! array fill
 -- C Function: scm_array_fill_x (array, fill)
     Store FILL in every element of ARRAY.  The value returned is
     unspecified.

 -- Scheme Procedure: array-equal? array ...
     Return `#t' if all arguments are arrays with the same shape, the
     same type, and have corresponding elements which are either
     `equal?' or `array-equal?'.  This function differs from `equal?'
     (*note Equality::) in that all arguments must be arrays.

 -- Scheme Procedure: array-map! dst proc src ...
 -- Scheme Procedure: array-map-in-order! dst proc src1 ... srcN
 -- C Function: scm_array_map_x (dst, proc, srclist)
     Set each element of the DST array to values obtained from calls to
     PROC.  The value returned is unspecified.

     Each call is `(PROC ELEM1 ... ELEMN)', where each ELEM is from the
     corresponding SRC array, at the DST index.  `array-map-in-order!'
     makes the calls in row-major order, `array-map!' makes them in an
     unspecified order.

     The SRC arrays must have the same number of dimensions as DST, and
     must have a range for each dimension which covers the range in
     DST.  This ensures all DST indices are valid in each SRC.

 -- Scheme Procedure: array-for-each proc src1 src2 ...
 -- C Function: scm_array_for_each (proc, src1, srclist)
     Apply PROC to each tuple of elements of SRC1 SRC2 ..., in
     row-major order.  The value returned is unspecified.

 -- Scheme Procedure: array-index-map! dst proc
 -- C Function: scm_array_index_map_x (dst, proc)
     Set each element of the DST array to values returned by calls to
     PROC.  The value returned is unspecified.

     Each call is `(PROC I1 ... IN)', where I1...IN is the destination
     index, one parameter for each dimension.  The order in which the
     calls are made is unspecified.

     For example, to create a 4x4 matrix representing a cyclic group,

              / 0 1 2 3 \
              | 1 2 3 0 |
              | 2 3 0 1 |
              \ 3 0 1 2 /

          (define a (make-array #f 4 4))
          (array-index-map! a (lambda (i j)
                                (modulo (+ i j) 4)))

 -- Scheme Procedure: uniform-array-read! ra [port_or_fd [start [end]]]
 -- C Function: scm_uniform_array_read_x (ra, port_or_fd, start, end)
     Attempt to read all elements of array RA, in lexicographic order,
     as binary objects from PORT_OR_FD.  If an end of file is
     encountered, the objects up to that point are put into RA
     (starting at the beginning) and the remainder of the array is
     unchanged.

     The optional arguments START and END allow a specified region of a
     vector (or linearized array) to be read, leaving the remainder of
     the vector unchanged.

     `uniform-array-read!' returns the number of objects read.
     PORT_OR_FD may be omitted, in which case it defaults to the value
     returned by `(current-input-port)'.

 -- Scheme Procedure: uniform-array-write ra [port_or_fd [start [end]]]
 -- C Function: scm_uniform_array_write (ra, port_or_fd, start, end)
     Writes all elements of RA as binary objects to PORT_OR_FD.

     The optional arguments START and END allow a specified region of a
     vector (or linearized array) to be written.

     The number of objects actually written is returned.  PORT_OR_FD
     may be omitted, in which case it defaults to the value returned by
     `(current-output-port)'.


File: guile.info,  Node: Shared Arrays,  Next: Accessing Arrays from C,  Prev: Array Procedures,  Up: Arrays

6.7.5.3 Shared Arrays
.....................

 -- Scheme Procedure: make-shared-array oldarray mapfunc bound ...
 -- C Function: scm_make_shared_array (oldarray, mapfunc, boundlist)
     Return a new array which shares the storage of OLDARRAY.  Changes
     made through either affect the same underlying storage.  The BOUND
     ... arguments are the shape of the new array, the same as
     `make-array' (*note Array Procedures::).

     MAPFUNC translates coordinates from the new array to the OLDARRAY.
     It's called as `(MAPFUNC newidx1 ...)' with one parameter for each
     dimension of the new array, and should return a list of indices
     for OLDARRAY, one for each dimension of OLDARRAY.

     MAPFUNC must be affine linear, meaning that each OLDARRAY index
     must be formed by adding integer multiples (possibly negative) of
     some or all of NEWIDX1 etc, plus a possible integer offset.  The
     multiples and offset must be the same in each call.


     One good use for a shared array is to restrict the range of some
     dimensions, so as to apply say `array-for-each' or `array-fill!'
     to only part of an array.  The plain `list' function can be used
     for MAPFUNC in this case, making no changes to the index values.
     For example,

          (make-shared-array #2((a b c) (d e f) (g h i)) list 3 2)
          => #2((a b) (d e) (g h))

     The new array can have fewer dimensions than OLDARRAY, for example
     to take a column from an array.

          (make-shared-array #2((a b c) (d e f) (g h i))
                             (lambda (i) (list i 2))
                             '(0 2))
          => #1(c f i)

     A diagonal can be taken by using the single new array index for
     both row and column in the old array.  For example,

          (make-shared-array #2((a b c) (d e f) (g h i))
                             (lambda (i) (list i i))
                             '(0 2))
          => #1(a e i)

     Dimensions can be increased by for instance considering portions
     of a one dimensional array as rows in a two dimensional array.
     (`array-contents' below can do the opposite, flattening an array.)

          (make-shared-array #1(a b c d e f g h i j k l)
                             (lambda (i j) (list (+ (* i 3) j)))
                             4 3)
          => #2((a b c) (d e f) (g h i) (j k l))

     By negating an index the order that elements appear can be
     reversed.  The following just reverses the column order,

          (make-shared-array #2((a b c) (d e f) (g h i))
                             (lambda (i j) (list i (- 2 j)))
                             3 3)
          => #2((c b a) (f e d) (i h g))

     A fixed offset on indexes allows for instance a change from a 0
     based to a 1 based array,

          (define x #2((a b c) (d e f) (g h i)))
          (define y (make-shared-array x
                                       (lambda (i j) (list (1- i) (1- j)))
                                       '(1 3) '(1 3)))
          (array-ref x 0 0) => a
          (array-ref y 1 1) => a

     A multiple on an index allows every Nth element of an array to be
     taken.  The following is every third element,

          (make-shared-array #1(a b c d e f g h i j k l)
                             (lambda (i) (list (* i 3)))
                             4)
          => #1(a d g j)

     The above examples can be combined to make weird and wonderful
     selections from an array, but it's important to note that because
     MAPFUNC must be affine linear, arbitrary permutations are not
     possible.

     In the current implementation, MAPFUNC is not called for every
     access to the new array but only on some sample points to
     establish a base and stride for new array indices in OLDARRAY
     data.  A few sample points are enough because MAPFUNC is linear.

 -- Scheme Procedure: shared-array-increments array
 -- C Function: scm_shared_array_increments (array)
     For each dimension, return the distance between elements in the
     root vector.

 -- Scheme Procedure: shared-array-offset array
 -- C Function: scm_shared_array_offset (array)
     Return the root vector index of the first element in the array.

 -- Scheme Procedure: shared-array-root array
 -- C Function: scm_shared_array_root (array)
     Return the root vector of a shared array.

 -- Scheme Procedure: array-contents array [strict]
 -- C Function: scm_array_contents (array, strict)
     If ARRAY may be "unrolled" into a one dimensional shared array
     without changing their order (last subscript changing fastest),
     then `array-contents' returns that shared array, otherwise it
     returns `#f'.  All arrays made by `make-array' and
     `make-typed-array' may be unrolled, some arrays made by
     `make-shared-array' may not be.

     If the optional argument STRICT is provided, a shared array will
     be returned only if its elements are stored internally contiguous
     in memory.

 -- Scheme Procedure: transpose-array array dim1 dim2 ...
 -- C Function: scm_transpose_array (array, dimlist)
     Return an array sharing contents with ARRAY, but with dimensions
     arranged in a different order.  There must be one DIM argument for
     each dimension of ARRAY.  DIM1, DIM2, ... should be integers
     between 0 and the rank of the array to be returned.  Each integer
     in that range must appear at least once in the argument list.

     The values of DIM1, DIM2, ... correspond to dimensions in the
     array to be returned, and their positions in the argument list to
     dimensions of ARRAY.  Several DIMs may have the same value, in
     which case the returned array will have smaller rank than ARRAY.

          (transpose-array '#2((a b) (c d)) 1 0) => #2((a c) (b d))
          (transpose-array '#2((a b) (c d)) 0 0) => #1(a d)
          (transpose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 1 0) =>
                          #2((a 4) (b 5) (c 6))


File: guile.info,  Node: Accessing Arrays from C,  Prev: Shared Arrays,  Up: Arrays

6.7.5.4 Accessing Arrays from C
...............................

For interworking with external C code, Guile provides an API to allow C
code to access the elements of a Scheme array.  In particular, for
uniform numeric arrays, the API exposes the underlying uniform data as a
C array of numbers of the relevant type.

   While pointers to the elements of an array are in use, the array
itself must be protected so that the pointer remains valid.  Such a
protected array is said to be "reserved".  A reserved array can be read
but modifications to it that would cause the pointer to its elements to
become invalid are prevented.  When you attempt such a modification, an
error is signalled.

   (This is similar to locking the array while it is in use, but without
the danger of a deadlock.  In a multi-threaded program, you will need
additional synchronization to avoid modifying reserved arrays.)

   You must take care to always unreserve an array after reserving it,
even in the presence of non-local exits.  If a non-local exit can
happen between these two calls, you should install a dynwind context
that releases the array when it is left (*note Dynamic Wind::).

   In addition, array reserving and unreserving must be properly
paired.  For instance, when reserving two or more arrays in a certain
order, you need to unreserve them in the opposite order.

   Once you have reserved an array and have retrieved the pointer to its
elements, you must figure out the layout of the elements in memory.
Guile allows slices to be taken out of arrays without actually making a
copy, such as making an alias for the diagonal of a matrix that can be
treated as a vector.  Arrays that result from such an operation are not
stored contiguously in memory and when working with their elements
directly, you need to take this into account.

   The layout of array elements in memory can be defined via a _mapping
function_ that computes a scalar position from a vector of indices.
The scalar position then is the offset of the element with the given
indices from the start of the storage block of the array.

   In Guile, this mapping function is restricted to be "affine": all
mapping functions of Guile arrays can be written as `p = b + c[0]*i[0]
+ c[1]*i[1] + ... + c[n-1]*i[n-1]' where `i[k]' is the kth index and
`n' is the rank of the array.  For example, a matrix of size 3x3 would
have `b == 0', `c[0] == 3' and `c[1] == 1'.  When you transpose this
matrix (with `transpose-array', say), you will get an array whose
mapping function has `b == 0', `c[0] == 1' and `c[1] == 3'.

   The function `scm_array_handle_dims' gives you (indirect) access to
the coefficients `c[k]'.

   Note that there are no functions for accessing the elements of a
character array yet.  Once the string implementation of Guile has been
changed to use Unicode, we will provide them.

 -- C Type: scm_t_array_handle
     This is a structure type that holds all information necessary to
     manage the reservation of arrays as explained above.  Structures
     of this type must be allocated on the stack and must only be
     accessed by the functions listed below.

 -- C Function: void scm_array_get_handle (SCM array,
          scm_t_array_handle *handle)
     Reserve ARRAY, which must be an array, and prepare HANDLE to be
     used with the functions below.  You must eventually call
     `scm_array_handle_release' on HANDLE, and do this in a properly
     nested fashion, as explained above.  The structure pointed to by
     HANDLE does not need to be initialized before calling this
     function.

 -- C Function: void scm_array_handle_release (scm_t_array_handle
          *handle)
     End the array reservation represented by HANDLE.  After a call to
     this function, HANDLE might be used for another reservation.

 -- C Function: size_t scm_array_handle_rank (scm_t_array_handle
          *handle)
     Return the rank of the array represented by HANDLE.

 -- C Type: scm_t_array_dim
     This structure type holds information about the layout of one
     dimension of an array.  It includes the following fields:

    `ssize_t lbnd'
    `ssize_t ubnd'
          The lower and upper bounds (both inclusive) of the
          permissible index range for the given dimension.  Both values
          can be negative, but LBND is always less than or equal to
          UBND.

    `ssize_t inc'
          The distance from one element of this dimension to the next.
          Note, too, that this can be negative.

 -- C Function: const scm_t_array_dim * scm_array_handle_dims
          (scm_t_array_handle *handle)
     Return a pointer to a C vector of information about the dimensions
     of the array represented by HANDLE.  This pointer is valid as long
     as the array remains reserved.  As explained above, the
     `scm_t_array_dim' structures returned by this function can be used
     calculate the position of an element in the storage block of the
     array from its indices.

     This position can then be used as an index into the C array pointer
     returned by the various `scm_array_handle_<foo>_elements'
     functions, or with `scm_array_handle_ref' and
     `scm_array_handle_set'.

     Here is how one can compute the position POS of an element given
     its indices in the vector INDICES:

          ssize_t indices[RANK];
          scm_t_array_dim *dims;
          ssize_t pos;
          size_t i;

          pos = 0;
          for (i = 0; i < RANK; i++)
            {
              if (indices[i] < dims[i].lbnd || indices[i] > dims[i].ubnd)
                out_of_range ();
              pos += (indices[i] - dims[i].lbnd) * dims[i].inc;
            }

 -- C Function: ssize_t scm_array_handle_pos (scm_t_array_handle
          *handle, SCM indices)
     Compute the position corresponding to INDICES, a list of indices.
     The position is computed as described above for
     `scm_array_handle_dims'.  The number of the indices and their
     range is checked and an appropriate error is signalled for invalid
     indices.

 -- C Function: SCM scm_array_handle_ref (scm_t_array_handle *handle,
          ssize_t pos)
     Return the element at position POS in the storage block of the
     array represented by HANDLE.  Any kind of array is acceptable.  No
     range checking is done on POS.

 -- C Function: void scm_array_handle_set (scm_t_array_handle *handle,
          ssize_t pos, SCM val)
     Set the element at position POS in the storage block of the array
     represented by HANDLE to VAL.  Any kind of array is acceptable.
     No range checking is done on POS.  An error is signalled when the
     array can not store VAL.

 -- C Function: const SCM * scm_array_handle_elements
          (scm_t_array_handle *handle)
     Return a pointer to the elements of a ordinary array of general
     Scheme values (i.e., a non-uniform array) for reading.  This
     pointer is valid as long as the array remains reserved.

 -- C Function: SCM * scm_array_handle_writable_elements
          (scm_t_array_handle *handle)
     Like `scm_array_handle_elements', but the pointer is good for
     reading and writing.

 -- C Function: const void * scm_array_handle_uniform_elements
          (scm_t_array_handle *handle)
     Return a pointer to the elements of a uniform numeric array for
     reading.  This pointer is valid as long as the array remains
     reserved.  The size of each element is given by
     `scm_array_handle_uniform_element_size'.

 -- C Function: void * scm_array_handle_uniform_writable_elements
          (scm_t_array_handle *handle)
     Like `scm_array_handle_uniform_elements', but the pointer is good
     reading and writing.

 -- C Function: size_t scm_array_handle_uniform_element_size
          (scm_t_array_handle *handle)
     Return the size of one element of the uniform numeric array
     represented by HANDLE.

 -- C Function: const scm_t_uint8 * scm_array_handle_u8_elements
          (scm_t_array_handle *handle)
 -- C Function: const scm_t_int8 * scm_array_handle_s8_elements
          (scm_t_array_handle *handle)
 -- C Function: const scm_t_uint16 * scm_array_handle_u16_elements
          (scm_t_array_handle *handle)
 -- C Function: const scm_t_int16 * scm_array_handle_s16_elements
          (scm_t_array_handle *handle)
 -- C Function: const scm_t_uint32 * scm_array_handle_u32_elements
          (scm_t_array_handle *handle)
 -- C Function: const scm_t_int32 * scm_array_handle_s32_elements
          (scm_t_array_handle *handle)
 -- C Function: const scm_t_uint64 * scm_array_handle_u64_elements
          (scm_t_array_handle *handle)
 -- C Function: const scm_t_int64 * scm_array_handle_s64_elements
          (scm_t_array_handle *handle)
 -- C Function: const float * scm_array_handle_f32_elements
          (scm_t_array_handle *handle)
 -- C Function: const double * scm_array_handle_f64_elements
          (scm_t_array_handle *handle)
 -- C Function: const float * scm_array_handle_c32_elements
          (scm_t_array_handle *handle)
 -- C Function: const double * scm_array_handle_c64_elements
          (scm_t_array_handle *handle)
     Return a pointer to the elements of a uniform numeric array of the
     indicated kind for reading.  This pointer is valid as long as the
     array remains reserved.

     The pointers for `c32' and `c64' uniform numeric arrays point to
     pairs of floating point numbers.  The even index holds the real
     part, the odd index the imaginary part of the complex number.

 -- C Function: scm_t_uint8 * scm_array_handle_u8_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: scm_t_int8 * scm_array_handle_s8_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: scm_t_uint16 * scm_array_handle_u16_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: scm_t_int16 * scm_array_handle_s16_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: scm_t_uint32 * scm_array_handle_u32_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: scm_t_int32 * scm_array_handle_s32_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: scm_t_uint64 * scm_array_handle_u64_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: scm_t_int64 * scm_array_handle_s64_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: float * scm_array_handle_f32_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: double * scm_array_handle_f64_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: float * scm_array_handle_c32_writable_elements
          (scm_t_array_handle *handle)
 -- C Function: double * scm_array_handle_c64_writable_elements
          (scm_t_array_handle *handle)
     Like `scm_array_handle_<kind>_elements', but the pointer is good
     for reading and writing.

 -- C Function: const scm_t_uint32 * scm_array_handle_bit_elements
          (scm_t_array_handle *handle)
     Return a pointer to the words that store the bits of the
     represented array, which must be a bit array.

     Unlike other arrays, bit arrays have an additional offset that
     must be figured into index calculations.  That offset is returned
     by `scm_array_handle_bit_elements_offset'.

     To find a certain bit you first need to calculate its position as
     explained above for `scm_array_handle_dims' and then add the
     offset.  This gives the absolute position of the bit, which is
     always a non-negative integer.

     Each word of the bit array storage block contains exactly 32 bits,
     with the least significant bit in that word having the lowest
     absolute position number.  The next word contains the next 32 bits.

     Thus, the following code can be used to access a bit whose position
     according to `scm_array_handle_dims' is given in POS:

          SCM bit_array;
          scm_t_array_handle handle;
          scm_t_uint32 *bits;
          ssize_t pos;
          size_t abs_pos;
          size_t word_pos, mask;

          scm_array_get_handle (&bit_array, &handle);
          bits = scm_array_handle_bit_elements (&handle);

          pos = ...
          abs_pos = pos + scm_array_handle_bit_elements_offset (&handle);
          word_pos = abs_pos / 32;
          mask = 1L << (abs_pos % 32);

          if (bits[word_pos] & mask)
            /* bit is set. */

          scm_array_handle_release (&handle);


 -- C Function: scm_t_uint32 * scm_array_handle_bit_writable_elements
          (scm_t_array_handle *handle)
     Like `scm_array_handle_bit_elements' but the pointer is good for
     reading and writing.  You must take care not to modify bits
     outside of the allowed index range of the array, even for
     contiguous arrays.


File: guile.info,  Node: VLists,  Next: Record Overview,  Prev: Arrays,  Up: Compound Data Types

6.7.6 VLists
------------

The `(ice-9 vlist)' module provides an implementation of the "VList"
data structure designed by Phil Bagwell in 2002.  VLists are immutable
lists, which can contain any Scheme object.  They improve on standard
Scheme linked lists in several areas:

   * Random access has typically constant-time complexity.

   * Computing the length of a VList has time complexity logarithmic in
     the number of elements.

   * VLists use less storage space than standard lists.

   * VList elements are stored in contiguous regions, which improves
     memory locality and leads to more efficient use of hardware caches.

   The idea behind VLists is to store vlist elements in increasingly
large contiguous blocks (implemented as vectors here).  These blocks
are linked to one another using a pointer to the next block and an
offset within that block.  The size of these blocks form a geometric
series with ratio `block-growth-factor' (2 by default).

   The VList structure also serves as the basis for the "VList-based
hash lists" or "vhashes", an immutable dictionary type (*note
VHashes::).

   However, the current implementation in `(ice-9 vlist)' has several
noteworthy shortcomings:

   * It is _not_ thread-safe.  Although operations on vlists are all
     "referentially transparent" (i.e., purely functional), adding
     elements to a vlist with `vlist-cons' mutates part of its internal
     structure, which makes it non-thread-safe.  This could be fixed,
     but it would slow down `vlist-cons'.

   * `vlist-cons' always allocates at least as much memory as `cons'.
     Again, Phil Bagwell describes how to fix it, but that would
     require tuning the garbage collector in a way that may not be
     generally beneficial.

   * `vlist-cons' is a Scheme procedure compiled to bytecode, and it
     does not compete with the straightforward C implementation of
     `cons', and with the fact that the VM has a special `cons'
     instruction.


   We hope to address these in the future.

   The programming interface exported by `(ice-9 vlist)' is defined
below.  Most of it is the same as SRFI-1 with an added `vlist-' prefix
to function names.

 -- Scheme Procedure: vlist? obj
     Return true if OBJ is a VList.

 -- Scheme Variable: vlist-null
     The empty VList.  Note that it's possible to create an empty VList
     not `eq?' to `vlist-null'; thus, callers should always use
     `vlist-null?' when testing whether a VList is empty.

 -- Scheme Procedure: vlist-null? vlist
     Return true if VLIST is empty.

 -- Scheme Procedure: vlist-cons item vlist
     Return a new vlist with ITEM as its head and VLIST as its tail.

 -- Scheme Procedure: vlist-head vlist
     Return the head of VLIST.

 -- Scheme Procedure: vlist-tail vlist
     Return the tail of VLIST.

 -- Scheme Variable: block-growth-factor
     A fluid that defines the growth factor of VList blocks, 2 by
     default.

   The functions below provide the usual set of higher-level list
operations.

 -- Scheme Procedure: vlist-fold proc init vlist
 -- Scheme Procedure: vlist-fold-right proc init vlist
     Fold over VLIST, calling PROC for each element, as for SRFI-1
     `fold' and `fold-right' (*note `fold': SRFI-1.).

 -- Scheme Procedure: vlist-ref vlist index
     Return the element at index INDEX in VLIST.  This is typically a
     constant-time operation.

 -- Scheme Procedure: vlist-length vlist
     Return the length of VLIST.  This is typically logarithmic in the
     number of elements in VLIST.

 -- Scheme Procedure: vlist-reverse vlist
     Return a new VLIST whose content are those of VLIST in reverse
     order.

 -- Scheme Procedure: vlist-map proc vlist
     Map PROC over the elements of VLIST and return a new vlist.

 -- Scheme Procedure: vlist-for-each proc vlist
     Call PROC on each element of VLIST.  The result is unspecified.

 -- Scheme Procedure: vlist-drop vlist count
     Return a new vlist that does not contain the COUNT first elements
     of VLIST.  This is typically a constant-time operation.

 -- Scheme Procedure: vlist-take vlist count
     Return a new vlist that contains only the COUNT first elements of
     VLIST.

 -- Scheme Procedure: vlist-filter pred vlist
     Return a new vlist containing all the elements from VLIST that
     satisfy PRED.

 -- Scheme Procedure: vlist-delete x vlist [equal?]
     Return a new vlist corresponding to VLIST without the elements
     EQUAL? to X.

 -- Scheme Procedure: vlist-unfold p f g seed [tail-gen]
 -- Scheme Procedure: vlist-unfold-right p f g seed [tail]
     Return a new vlist, as for SRFI-1 `unfold' and `unfold-right'
     (*note `unfold': SRFI-1.).

 -- Scheme Procedure: vlist-append vlist ...
     Append the given vlists and return the resulting vlist.

 -- Scheme Procedure: list->vlist lst
     Return a new vlist whose contents correspond to LST.

 -- Scheme Procedure: vlist->list vlist
     Return a new list whose contents match those of VLIST.


File: guile.info,  Node: Record Overview,  Next: SRFI-9 Records,  Prev: VLists,  Up: Compound Data Types

6.7.7 Record Overview
---------------------

"Records", also called "structures", are Scheme's primary mechanism to
define new disjoint types.  A "record type" defines a list of "fields"
that instances of the type consist of.  This is like C's `struct'.

   Historically, Guile has offered several different ways to define
record types and to create records, offering different features, and
making different trade-offs.  Over the years, each "standard" has also
come with its own new record interface, leading to a maze of record
APIs.

   At the highest level is SRFI-9, a high-level record interface
implemented by most Scheme implementations (*note SRFI-9 Records::).  It
defines a simple and efficient syntactic abstraction of record types and
their associated type predicate, fields, and field accessors.  SRFI-9 is
suitable for most uses, and this is the recommended way to create record
types in Guile.  Similar high-level record APIs include SRFI-35 (*note
SRFI-35::) and R6RS records (*note rnrs records syntactic::).

   Then comes Guile's historical "records" API (*note Records::).
Record types defined this way are first-class objects.  Introspection
facilities are available, allowing users to query the list of fields or
the value of a specific field at run-time, without prior knowledge of
the type.

   Finally, the common denominator of these interfaces is Guile's
"structure" API (*note Structures::).  Guile's structures are the
low-level building block for all other record APIs.  Application writers
will normally not need to use it.

   Records created with these APIs may all be pattern-matched using
Guile's standard pattern matcher (*note Pattern Matching::).


File: guile.info,  Node: SRFI-9 Records,  Next: Records,  Prev: Record Overview,  Up: Compound Data Types

6.7.8 SRFI-9 Records
--------------------

SRFI-9 standardizes a syntax for defining new record types and creating
predicate, constructor, and field getter and setter functions.  In Guile
this is the recommended option to create new record types (*note Record
Overview::).  It can be used with:

     (use-modules (srfi srfi-9))

 -- Scheme Syntax: define-record-type type
          (constructor fieldname ...)
          predicate
          (fieldname accessor [modifier]) ...

     Create a new record type, and make various `define's for using it.
     This syntax can only occur at the top-level, not nested within
     some other form.

     TYPE is bound to the record type, which is as per the return from
     the core `make-record-type'.  TYPE also provides the name for the
     record, as per `record-type-name'.

     CONSTRUCTOR is bound to a function to be called as `(CONSTRUCTOR
     fieldval ...)' to create a new record of this type.  The arguments
     are initial values for the fields, one argument for each field, in
     the order they appear in the `define-record-type' form.

     The FIELDNAMEs provide the names for the record fields, as per the
     core `record-type-fields' etc, and are referred to in the
     subsequent accessor/modifier forms.

     PREDICATE is bound to a function to be called as `(PREDICATE
     obj)'.  It returns `#t' or `#f' according to whether OBJ is a
     record of this type.

     Each ACCESSOR is bound to a function to be called `(ACCESSOR
     record)' to retrieve the respective field from a RECORD.
     Similarly each MODIFIER is bound to a function to be called
     `(MODIFIER record val)' to set the respective field in a RECORD.

An example will illustrate typical usage,

     (define-record-type <employee>
       (make-employee name age salary)
       employee?
       (name    employee-name)
       (age     employee-age    set-employee-age!)
       (salary  employee-salary set-employee-salary!))

   This creates a new employee data type, with name, age and salary
fields.  Accessor functions are created for each field, but no modifier
function for the name (the intention in this example being that it's
established only when an employee object is created).  These can all
then be used as for example,

     <employee> => #<record-type <employee>>

     (define fred (make-employee "Fred" 45 20000.00))

     (employee? fred)        => #t
     (employee-age fred)     => 45
     (set-employee-salary! fred 25000.00)  ;; pay rise

   The functions created by `define-record-type' are ordinary top-level
`define's.  They can be redefined or `set!' as desired, exported from a
module, etc.

Non-toplevel Record Definitions
...............................

The SRFI-9 specification explicitly disallows record definitions in a
non-toplevel context, such as inside `lambda' body or inside a LET
block.  However, Guile's implementation does not enforce that
restriction.

Custom Printers
...............

You may use `set-record-type-printer!' to customize the default printing
behavior of records.  This is a Guile extension and is not part of
SRFI-9.  It is located in the (srfi srfi-9 gnu) module.

 -- Scheme Syntax: set-record-type-printer! name proc
     Where TYPE corresponds to the first argument of
     `define-record-type', and PROC is a procedure accepting two
     arguments, the record to print, and an output port.

This example prints the employee's name in brackets, for instance
`[Fred]'.

     (set-record-type-printer! <employee>
       (lambda (record port)
         (write-char #\[ port)
         (display (employee-name record) port)
         (write-char #\] port)))

Functional "Setters"
....................

When writing code in a functional style, it is desirable to never alter
the contents of records.  For such code, a simple way to return new
record instances based on existing ones is highly desirable.

   The `(srfi srfi-9 gnu)' module extends SRFI-9 with facilities to
return new record instances based on existing ones, only with one or
more field values changed--"functional setters".  First, the
`define-immutable-record-type' works like `define-record-type', except
that fields are immutable and setters are defined as functional setters.

 -- Scheme Syntax: define-immutable-record-type type
          (constructor fieldname ...)
          predicate
          (fieldname accessor [modifier]) ...
     Define TYPE as a new record type, like `define-record-type'.
     However, the record type is made _immutable_ (records may not be
     mutated, even with `struct-set!'), and any MODIFIER is defined to
     be a functional setter--a procedure that returns a new record
     instance with the specified field changed, and leaves the original
     unchanged (see example below.)

In addition, the generic `set-field' and `set-fields' macros may be
applied to any SRFI-9 record.

 -- Scheme Syntax: set-field record (field sub-fields ...) value
     Return a new record of RECORD's type whose fields are equal to the
     corresponding fields of RECORD except for the one specified by
     FIELD.

     FIELD must be the name of the getter corresponding to the field of
     RECORD being "set".  Subsequent SUB-FIELDS must be record getters
     designating sub-fields within that field value to be set (see
     example below.)

 -- Scheme Syntax: set-fields record ((field sub-fields ...) value) ...
     Like `set-field', but can be used to set more than one field at a
     time.  This expands to code that is more efficient than a series of
     single `set-field' calls.

   To illustrate the use of functional setters, let's assume these two
record type definitions:

     (define-record-type <address>
       (address street city country)
       address?
       (street  address-street)
       (city    address-city)
       (country address-country))

     (define-immutable-record-type <person>
       (person age email address)
       person?
       (age     person-age set-person-age)
       (email   person-email set-person-email)
       (address person-address set-person-address))

First, note that the `<person>' record type definition introduces named
functional setters.  These may be used like this:

     (define fsf-address
       (address "Franklin Street" "Boston" "USA"))

     (define rms
       (person 30 "rms@gnu.org" fsf-address))

     (and (equal? (set-person-age rms 60)
                  (person 60 "rms@gnu.org" fsf-address))
          (= (person-age rms) 30))
     => #t

Here, the original `<person>' record, to which RMS is bound, is left
unchanged.

   Now, suppose we want to change both the street and age of RMS.  This
can be achieved using `set-fields':

     (set-fields rms
       ((person-age) 60)
       ((person-address address-street) "Temple Place"))
     => #<<person> age: 60 email: "rms@gnu.org"
       address: #<<address> street: "Temple Place" city: "Boston" country: "USA">>

Notice how the above changed two fields of RMS, including the `street'
field of its `address' field, in a concise way.  Also note that
`set-fields' works equally well for types defined with just
`define-record-type'.


File: guile.info,  Node: Records,  Next: Structures,  Prev: SRFI-9 Records,  Up: Compound Data Types

6.7.9 Records
-------------

A "record type" is a first class object representing a user-defined
data type.  A "record" is an instance of a record type.

   Note that in many ways, this interface is too low-level for every-day
use.  Most uses of records are better served by SRFI-9 records.  *Note
SRFI-9 Records::.

 -- Scheme Procedure: record? obj
     Return `#t' if OBJ is a record of any type and `#f' otherwise.

     Note that `record?' may be true of any Scheme value; there is no
     promise that records are disjoint with other Scheme types.

 -- Scheme Procedure: make-record-type type-name field-names [print]
     Create and return a new "record-type descriptor".

     TYPE-NAME is a string naming the type.  Currently it's only used
     in the printed representation of records, and in diagnostics.
     FIELD-NAMES is a list of symbols naming the fields of a record of
     the type.  Duplicates are not allowed among these symbols.

          (make-record-type "employee" '(name age salary))

     The optional PRINT argument is a function used by `display',
     `write', etc, for printing a record of the new type.  It's called
     as `(PRINT record port)' and should look at RECORD and write to
     PORT.

 -- Scheme Procedure: record-constructor rtd [field-names]
     Return a procedure for constructing new members of the type
     represented by RTD.  The returned procedure accepts exactly as
     many arguments as there are symbols in the given list,
     FIELD-NAMES; these are used, in order, as the initial values of
     those fields in a new record, which is returned by the constructor
     procedure.  The values of any fields not named in that list are
     unspecified.  The FIELD-NAMES argument defaults to the list of
     field names in the call to `make-record-type' that created the
     type represented by RTD; if the FIELD-NAMES argument is provided,
     it is an error if it contains any duplicates or any symbols not in
     the default list.

 -- Scheme Procedure: record-predicate rtd
     Return a procedure for testing membership in the type represented
     by RTD.  The returned procedure accepts exactly one argument and
     returns a true value if the argument is a member of the indicated
     record type; it returns a false value otherwise.

 -- Scheme Procedure: record-accessor rtd field-name
     Return a procedure for reading the value of a particular field of a
     member of the type represented by RTD.  The returned procedure
     accepts exactly one argument which must be a record of the
     appropriate type; it returns the current value of the field named
     by the symbol FIELD-NAME in that record.  The symbol FIELD-NAME
     must be a member of the list of field-names in the call to
     `make-record-type' that created the type represented by RTD.

 -- Scheme Procedure: record-modifier rtd field-name
     Return a procedure for writing the value of a particular field of a
     member of the type represented by RTD.  The returned procedure
     accepts exactly two arguments: first, a record of the appropriate
     type, and second, an arbitrary Scheme value; it modifies the field
     named by the symbol FIELD-NAME in that record to contain the given
     value.  The returned value of the modifier procedure is
     unspecified.  The symbol FIELD-NAME must be a member of the list
     of field-names in the call to `make-record-type' that created the
     type represented by RTD.

 -- Scheme Procedure: record-type-descriptor record
     Return a record-type descriptor representing the type of the given
     record.  That is, for example, if the returned descriptor were
     passed to `record-predicate', the resulting predicate would return
     a true value when passed the given record.  Note that it is not
     necessarily the case that the returned descriptor is the one that
     was passed to `record-constructor' in the call that created the
     constructor procedure that created the given record.

 -- Scheme Procedure: record-type-name rtd
     Return the type-name associated with the type represented by rtd.
     The returned value is `eqv?' to the TYPE-NAME argument given in
     the call to `make-record-type' that created the type represented by
     RTD.

 -- Scheme Procedure: record-type-fields rtd
     Return a list of the symbols naming the fields in members of the
     type represented by RTD.  The returned value is `equal?' to the
     field-names argument given in the call to `make-record-type' that
     created the type represented by RTD.


File: guile.info,  Node: Structures,  Next: Dictionary Types,  Prev: Records,  Up: Compound Data Types

6.7.10 Structures
-----------------

A "structure" is a first class data type which holds Scheme values or C
words in fields numbered 0 upwards.  A "vtable" is a structure that
represents a structure type, giving field types and permissions, and an
optional print function for `write' etc.

   Structures are lower level than records (*note Records::).  Usually,
when you need to represent structured data, you just want to use
records.  But sometimes you need to implement new kinds of structured
data abstractions, and for that purpose structures are useful.  Indeed,
records in Guile are implemented with structures.

* Menu:

* Vtables::
* Structure Basics::
* Vtable Contents::
* Meta-Vtables::
* Vtable Example::
* Tail Arrays::


File: guile.info,  Node: Vtables,  Next: Structure Basics,  Up: Structures

6.7.10.1 Vtables
................

A vtable is a structure type, specifying its layout, and other
information.  A vtable is actually itself a structure, but there's no
need to worry about that initially (*note Vtable Contents::.)

 -- Scheme Procedure: make-vtable fields [print]
     Create a new vtable.

     FIELDS is a string describing the fields in the structures to be
     created.  Each field is represented by two characters, a type
     letter and a permissions letter, for example `"pw"'.  The types
     are as follows.

        * `p' - a Scheme value.  "p" stands for "protected" meaning
          it's protected against garbage collection.

        * `u' - an arbitrary word of data (an `scm_t_bits').  At the
          Scheme level it's read and written as an unsigned integer.
          "u" stands for "uninterpreted" (it's not treated as a Scheme
          value), or "unprotected" (it's not marked during GC), or
          "unsigned long" (its size), or all of these things.

        * `s' - a self-reference.  Such a field holds the `SCM' value
          of the structure itself (a circular reference).  This can be
          useful in C code where you might have a pointer to the data
          array, and want to get the Scheme `SCM' handle for the
          structure.  In Scheme code it has no use.

     The second letter for each field is a permission code,

        * `w' - writable, the field can be read and written.

        * `r' - read-only, the field can be read but not written.

        * `o' - opaque, the field can be neither read nor written at the
          Scheme level.  This can be used for fields which should only
          be used from C code.

     Here are some examples.  *Note Tail Arrays::, for information on
     the legacy tail array facility.

          (make-vtable "pw")      ;; one writable field
          (make-vtable "prpw")    ;; one read-only and one writable
          (make-vtable "pwuwuw")  ;; one scheme and two uninterpreted

     The optional PRINT argument is a function called by `display' and
     `write' (etc) to give a printed representation of a structure
     created from this vtable.  It's called `(PRINT struct port)' and
     should look at STRUCT and write to PORT.  The default print merely
     gives a form like `#<struct ADDR:ADDR>' with a pair of machine
     addresses.

     The following print function for example shows the two fields of
     its structure.

          (make-vtable "prpw"
                       (lambda (struct port)
                         (format port "#<~a and ~a>"
                                 (struct-ref struct 0)
                                 (struct-ref struct 1))))


File: guile.info,  Node: Structure Basics,  Next: Vtable Contents,  Prev: Vtables,  Up: Structures

6.7.10.2 Structure Basics
.........................

This section describes the basic procedures for working with
structures.  `make-struct' creates a structure, and `struct-ref' and
`struct-set!' access its fields.

 -- Scheme Procedure: make-struct vtable tail-size init ...
 -- Scheme Procedure: make-struct/no-tail vtable init ...
     Create a new structure, with layout per the given VTABLE (*note
     Vtables::).

     The optional INIT... arguments are initial values for the fields
     of the structure.  This is the only way to put values in read-only
     fields.  If there are fewer INIT arguments than fields then the
     defaults are `#f' for a Scheme field (type `p') or 0 for an
     uninterpreted field (type `u').

     Structures also have the ability to allocate a variable number of
     additional cells at the end, at their tails.  However, this legacy
     "tail array" facilty is confusing and inefficient, and so we do not
     recommend it.  *Note Tail Arrays::, for more on the legacy tail
     array interface.

     Type `s' self-reference fields, permission `o' opaque fields, and
     the count field of a tail array are all ignored for the INIT
     arguments, ie. an argument is not consumed by such a field.  An
     `s' is always set to the structure itself, an `o' is always set to
     `#f' or 0 (with the intention that C code will do something to it
     later), and the tail count is always the given TAIL-SIZE.

     For example,

          (define v (make-vtable "prpwpw"))
          (define s (make-struct v 0 123 "abc" 456))
          (struct-ref s 0) => 123
          (struct-ref s 1) => "abc"

 -- C Function: SCM scm_make_struct (SCM vtable, SCM tail_size, SCM
          init_list)
 -- C Function: SCM scm_c_make_struct (SCM vtable, SCM tail_size, SCM
          init, ...)
 -- C Function: SCM scm_c_make_structv (SCM vtable, SCM tail_size,
          size_t n_inits, scm_t_bits init[])
     There are a few ways to make structures from C.  `scm_make_struct'
     takes a list, `scm_c_make_struct' takes variable arguments
     terminated with SCM_UNDEFINED, and `scm_c_make_structv' takes a
     packed array.

 -- Scheme Procedure: struct? obj
 -- C Function: scm_struct_p (obj)
     Return `#t' if OBJ is a structure, or `#f' if not.

 -- Scheme Procedure: struct-ref struct n
 -- C Function: scm_struct_ref (struct, n)
     Return the contents of field number N in STRUCT.  The first field
     is number 0.

     An error is thrown if N is out of range, or if the field cannot be
     read because it's `o' opaque.

 -- Scheme Procedure: struct-set! struct n value
 -- C Function: scm_struct_set_x (struct, n, value)
     Set field number N in STRUCT to VALUE.  The first field is number
     0.

     An error is thrown if N is out of range, or if the field cannot be
     written because it's `r' read-only or `o' opaque.

 -- Scheme Procedure: struct-vtable struct
 -- C Function: scm_struct_vtable (struct)
     Return the vtable that describes STRUCT.

     The vtable is effectively the type of the structure.  See *note
     Vtable Contents::, for more on vtables.


File: guile.info,  Node: Vtable Contents,  Next: Meta-Vtables,  Prev: Structure Basics,  Up: Structures

6.7.10.3 Vtable Contents
........................

A vtable is itself a structure.  It has a specific set of fields
describing various aspects of its "instances": the structures created
from a vtable.  Some of the fields are internal to Guile, some of them
are part of the public interface, and there may be additional fields
added on by the user.

   Every vtable has a field for the layout of their instances, a field
for the procedure used to print its instances, and a field for the name
of the vtable itself.  Access to the layout and printer is exposed
directly via field indexes.  Access to the vtable name is exposed via
accessor procedures.

 -- Scheme Variable: vtable-index-layout
 -- C Macro: scm_vtable_index_layout
     The field number of the layout specification in a vtable.  The
     layout specification is a symbol like `pwpw' formed from the fields
     string passed to `make-vtable', or created by `make-struct-layout'
     (*note Meta-Vtables::).

          (define v (make-vtable "pwpw" 0))
          (struct-ref v vtable-index-layout) => pwpw

     This field is read-only, since the layout of structures using a
     vtable cannot be changed.

 -- Scheme Variable: vtable-index-printer
 -- C Macro: scm_vtable_index_printer
     The field number of the printer function.  This field contains `#f'
     if the default print function should be used.

          (define (my-print-func struct port)
            ...)
          (define v (make-vtable "pwpw" my-print-func))
          (struct-ref v vtable-index-printer) => my-print-func

     This field is writable, allowing the print function to be changed
     dynamically.

 -- Scheme Procedure: struct-vtable-name vtable
 -- Scheme Procedure: set-struct-vtable-name! vtable name
 -- C Function: scm_struct_vtable_name (vtable)
 -- C Function: scm_set_struct_vtable_name_x (vtable, name)
     Get or set the name of VTABLE.  NAME is a symbol and is used in
     the default print function when printing structures created from
     VTABLE.

          (define v (make-vtable "pw"))
          (set-struct-vtable-name! v 'my-name)

          (define s (make-struct v 0))
          (display s) -| #<my-name b7ab3ae0:b7ab3730>


File: guile.info,  Node: Meta-Vtables,  Next: Vtable Example,  Prev: Vtable Contents,  Up: Structures

6.7.10.4 Meta-Vtables
.....................

As a structure, a vtable also has a vtable, which is also a structure.
Structures, their vtables, the vtables of the vtables, and so on form a
tree of structures.  Making a new structure adds a leaf to the tree, and
if that structure is a vtable, it may be used to create other leaves.

   If you traverse up the tree of vtables, via calling `struct-vtable',
eventually you reach a root which is the vtable of itself:

     scheme@(guile-user)> (current-module)
     $1 = #<directory (guile-user) 221b090>
     scheme@(guile-user)> (struct-vtable $1)
     $2 = #<record-type module>
     scheme@(guile-user)> (struct-vtable $2)
     $3 = #<<standard-vtable> 12c30a0>
     scheme@(guile-user)> (struct-vtable $3)
     $4 = #<<standard-vtable> 12c3fa0>
     scheme@(guile-user)> (struct-vtable $4)
     $5 = #<<standard-vtable> 12c3fa0>
     scheme@(guile-user)> <standard-vtable>
     $6 = #<<standard-vtable> 12c3fa0>

   In this example, we can say that `$1' is an instance of `$2', `$2'
is an instance of `$3', `$3' is an instance of `$4', and `$4',
strangely enough, is an instance of itself.  The value bound to `$4' in
this console session also bound to `<standard-vtable>' in the default
environment.

 -- Scheme Variable: <standard-vtable>
     A meta-vtable, useful for making new vtables.

   All of these values are structures.  All but `$1' are vtables.  As
`$2' is an instance of `$3', and `$3' is a vtable, we can say that `$3'
is a "meta-vtable": a vtable that can create vtables.

   With this definition, we can specify more precisely what a vtable
is: a vtable is a structure made from a meta-vtable.  Making a
structure from a meta-vtable runs some special checks to ensure that
the first field of the structure is a valid layout.  Additionally, if
these checks see that the layout of the child vtable contains all the
required fields of a vtable, in the correct order, then the child
vtable will also be a meta-table, inheriting a magical bit from the
parent.

 -- Scheme Procedure: struct-vtable? obj
 -- C Function: scm_struct_vtable_p (obj)
     Return `#t' if OBJ is a vtable structure: an instance of a
     meta-vtable.

   `<standard-vtable>' is a root of the vtable tree.  (Normally there
is only one root in a given Guile process, but due to some legacy
interfaces there may be more than one.)

   The set of required fields of a vtable is the set of fields in the
`<standard-vtable>', and is bound to `standard-vtable-fields' in the
default environment.  It is possible to create a meta-vtable that with
additional fields in its layout, which can be used to create vtables
with additional data:

     scheme@(guile-user)> (struct-ref $3 vtable-index-layout)
     $6 = pruhsruhpwphuhuhprprpw
     scheme@(guile-user)> (struct-ref $4 vtable-index-layout)
     $7 = pruhsruhpwphuhuh
     scheme@(guile-user)> standard-vtable-fields
     $8 = "pruhsruhpwphuhuh"
     scheme@(guile-user)> (struct-ref $2 vtable-offset-user)
     $9 = module

   In this continuation of our earlier example, `$2' is a vtable that
has extra fields, because its vtable, `$3', was made from a meta-vtable
with an extended layout.  `vtable-offset-user' is a convenient
definition that indicates the number of fields in
`standard-vtable-fields'.

 -- Scheme Variable: standard-vtable-fields
     A string containing the orderedq set of fields that a vtable must
     have.

 -- Scheme Variable: vtable-offset-user
     The first index in a vtable that is available for a user.

 -- Scheme Procedure: make-struct-layout fields
 -- C Function: scm_make_struct_layout (fields)
     Return a structure layout symbol, from a FIELDS string.  FIELDS is
     as described under `make-vtable' (*note Vtables::).  An invalid
     FIELDS string is an error.

   With these definitions, one can define `make-vtable' in this way:

     (define* (make-vtable fields #:optional printer)
       (make-struct/no-tail <standard-vtable>
         (make-struct-layout fields)
         printer))


File: guile.info,  Node: Vtable Example,  Next: Tail Arrays,  Prev: Meta-Vtables,  Up: Structures

6.7.10.5 Vtable Example
.......................

Let us bring these points together with an example.  Consider a simple
object system with single inheritance.  Objects will be normal
structures, and classes will be vtables with three extra class fields:
the name of the class, the parent class, and the list of fields.

   So, first we need a meta-vtable that allocates instances with these
extra class fields.

     (define <class>
       (make-vtable
        (string-append standard-vtable-fields "pwpwpw")
        (lambda (x port)
          (format port "<<class> ~a>" (class-name x)))))

     (define (class? x)
       (and (struct? x)
            (eq? (struct-vtable x) <class>)))

   To make a structure with a specific meta-vtable, we will use
`make-struct/no-tail', passing it the computed instance layout and
printer, as with `make-vtable', and additionally the extra three class
fields.

     (define (make-class name parent fields)
       (let* ((fields (compute-fields parent fields))
              (layout (compute-layout fields)))
         (make-struct/no-tail <class>
           layout
           (lambda (x port)
             (print-instance x port))
           name
           parent
           fields)))

   Instances will store their associated data in slots in the
structure: as many slots as there are fields.  The `compute-layout'
procedure below can compute a layout, and `field-index' returns the slot
corresponding to a field.

     (define-syntax-rule (define-accessor name n)
       (define (name obj)
         (struct-ref obj n)))

     ;; Accessors for classes
     (define-accessor class-name (+ vtable-offset-user 0))
     (define-accessor class-parent (+ vtable-offset-user 1))
     (define-accessor class-fields (+ vtable-offset-user 2))

     (define (compute-fields parent fields)
       (if parent
           (append (class-fields parent) fields)
           fields))

     (define (compute-layout fields)
       (make-struct-layout
        (string-concatenate (make-list (length fields) "pw"))))

     (define (field-index class field)
       (list-index (class-fields class) field))

     (define (print-instance x port)
       (format port "<~a" (class-name (struct-vtable x)))
       (for-each (lambda (field idx)
                   (format port " ~a: ~a" field (struct-ref x idx)))
                 (class-fields (struct-vtable x))
                 (iota (length (class-fields (struct-vtable x)))))
       (format port ">"))

   So, at this point we can actually make a few classes:

     (define-syntax-rule (define-class name parent field ...)
       (define name (make-class 'name parent '(field ...))))

     (define-class <surface> #f
       width height)

     (define-class <window> <surface>
       x y)

   And finally, make an instance:

     (make-struct/no-tail <window> 400 300 10 20)
     => <<window> width: 400 height: 300 x: 10 y: 20>

   And that's that.  Note that there are many possible optimizations and
feature enhancements that can be made to this object system, and the
included GOOPS system does make most of them.  For more simple use
cases, the records facility is usually sufficient.  But sometimes you
need to make new kinds of data abstractions, and for that purpose,
structs are here.


File: guile.info,  Node: Tail Arrays,  Prev: Vtable Example,  Up: Structures

6.7.10.6 Tail Arrays
....................

Guile's structures have a facility whereby each instance of a vtable can
contain a variable-length tail array of values.  The length of the tail
array is stored in the structure.  This facility was originally intended
to allow C code to expose raw C structures with word-sized tail arrays
to Scheme.

   However, the tail array facility is confusing and doesn't work very
well.  It is very rarely used, but it insinuates itself into all
invocations of `make-struct'.  For this reason the clumsily-named
`make-struct/no-tail' procedure can actually be more elegant in actual
use, because it doesn't have a random `0' argument stuck in the middle.

   Tail arrays also inhibit optimization by allowing instances to affect
their shapes.  In the absence of tail arrays, all instances of a given
vtable have the same number and kinds of fields.  This uniformity can be
exploited by the runtime and the optimizer.  The presence of tail arrays
make some of these optimizations more difficult.

   Finally, the tail array facility is ad-hoc and does not compose with
the rest of Guile.  If a Guile user wants an array with user-specified
length, it's best to use a vector.  It is more clear in the code, and
the standard optimization techniques will do a good job with it.

   That said, we should mention some details about the interface.  A
vtable that has tail array has upper-case permission descriptors: `W',
`R' or `O', correspoding to tail arrays of writable, read-only, or
opaque elements.  A tail array permission descriptor may only appear in
the last element of a vtable layout.

   For exampple, `pW' indicates a tail of writable Scheme-valued
fields.  The `pW' field itself holds the tail size, and the tail fields
come after it.

     (define v (make-vtable "prpW")) ;; one fixed then a tail array
     (define s (make-struct v 6 "fixed field" 'x 'y))
     (struct-ref s 0) => "fixed field"
     (struct-ref s 1) => 2    ;; tail size
     (struct-ref s 2) => x    ;; tail array ...
     (struct-ref s 3) => y
     (struct-ref s 4) => #f


File: guile.info,  Node: Dictionary Types,  Next: Association Lists,  Prev: Structures,  Up: Compound Data Types

6.7.11 Dictionary Types
-----------------------

A "dictionary" object is a data structure used to index information in
a user-defined way.  In standard Scheme, the main aggregate data types
are lists and vectors.  Lists are not really indexed at all, and
vectors are indexed only by number (e.g. `(vector-ref foo 5)').  Often
you will find it useful to index your data on some other type; for
example, in a library catalog you might want to look up a book by the
name of its author.  Dictionaries are used to help you organize
information in such a way.

   An "association list" (or "alist" for short) is a list of key-value
pairs.  Each pair represents a single quantity or object; the `car' of
the pair is a key which is used to identify the object, and the `cdr'
is the object's value.

   A "hash table" also permits you to index objects with arbitrary
keys, but in a way that makes looking up any one object extremely fast.
A well-designed hash system makes hash table lookups almost as fast as
conventional array or vector references.

   Alists are popular among Lisp programmers because they use only the
language's primitive operations (lists, "car", "cdr" and the equality
primitives).  No changes to the language core are necessary.
Therefore, with Scheme's built-in list manipulation facilities, it is
very convenient to handle data stored in an association list.  Also,
alists are highly portable and can be easily implemented on even the
most minimal Lisp systems.

   However, alists are inefficient, especially for storing large
quantities of data.  Because we want Guile to be useful for large
software systems as well as small ones, Guile provides a rich set of
tools for using either association lists or hash tables.


File: guile.info,  Node: Association Lists,  Next: VHashes,  Prev: Dictionary Types,  Up: Compound Data Types

6.7.12 Association Lists
------------------------

An association list is a conventional data structure that is often used
to implement simple key-value databases.  It consists of a list of
entries in which each entry is a pair.  The "key" of each entry is the
`car' of the pair and the "value" of each entry is the `cdr'.

     ASSOCIATION LIST ::=  '( (KEY1 . VALUE1)
                              (KEY2 . VALUE2)
                              (KEY3 . VALUE3)
                              ...
                            )

Association lists are also known, for short, as "alists".

   The structure of an association list is just one example of the
infinite number of possible structures that can be built using pairs
and lists.  As such, the keys and values in an association list can be
manipulated using the general list structure procedures `cons', `car',
`cdr', `set-car!', `set-cdr!' and so on.  However, because association
lists are so useful, Guile also provides specific procedures for
manipulating them.

* Menu:

* Alist Key Equality::
* Adding or Setting Alist Entries::
* Retrieving Alist Entries::
* Removing Alist Entries::
* Sloppy Alist Functions::
* Alist Example::


File: guile.info,  Node: Alist Key Equality,  Next: Adding or Setting Alist Entries,  Up: Association Lists

6.7.12.1 Alist Key Equality
...........................

All of Guile's dedicated association list procedures, apart from
`acons', come in three flavours, depending on the level of equality
that is required to decide whether an existing key in the association
list is the same as the key that the procedure call uses to identify the
required entry.

   * Procedures with "assq" in their name use `eq?' to determine key
     equality.

   * Procedures with "assv" in their name use `eqv?' to determine key
     equality.

   * Procedures with "assoc" in their name use `equal?' to determine
     key equality.

   `acons' is an exception because it is used to build association
lists which do not require their entries' keys to be unique.


File: guile.info,  Node: Adding or Setting Alist Entries,  Next: Retrieving Alist Entries,  Prev: Alist Key Equality,  Up: Association Lists

6.7.12.2 Adding or Setting Alist Entries
........................................

`acons' adds a new entry to an association list and returns the
combined association list.  The combined alist is formed by consing the
new entry onto the head of the alist specified in the `acons' procedure
call.  So the specified alist is not modified, but its contents become
shared with the tail of the combined alist that `acons' returns.

   In the most common usage of `acons', a variable holding the original
association list is updated with the combined alist:

     (set! address-list (acons name address address-list))

   In such cases, it doesn't matter that the old and new values of
`address-list' share some of their contents, since the old value is
usually no longer independently accessible.

   Note that `acons' adds the specified new entry regardless of whether
the alist may already contain entries with keys that are, in some
sense, the same as that of the new entry.  Thus `acons' is ideal for
building alists where there is no concept of key uniqueness.

     (set! task-list (acons 3 "pay gas bill" '()))
     task-list
     =>
     ((3 . "pay gas bill"))

     (set! task-list (acons 3 "tidy bedroom" task-list))
     task-list
     =>
     ((3 . "tidy bedroom") (3 . "pay gas bill"))

   `assq-set!', `assv-set!' and `assoc-set!' are used to add or replace
an entry in an association list where there _is_ a concept of key
uniqueness.  If the specified association list already contains an
entry whose key is the same as that specified in the procedure call,
the existing entry is replaced by the new one.  Otherwise, the new
entry is consed onto the head of the old association list to create the
combined alist.  In all cases, these procedures return the combined
alist.

   `assq-set!' and friends _may_ destructively modify the structure of
the old association list in such a way that an existing variable is
correctly updated without having to `set!' it to the value returned:

     address-list
     =>
     (("mary" . "34 Elm Road") ("james" . "16 Bow Street"))

     (assoc-set! address-list "james" "1a London Road")
     =>
     (("mary" . "34 Elm Road") ("james" . "1a London Road"))

     address-list
     =>
     (("mary" . "34 Elm Road") ("james" . "1a London Road"))

   Or they may not:

     (assoc-set! address-list "bob" "11 Newington Avenue")
     =>
     (("bob" . "11 Newington Avenue") ("mary" . "34 Elm Road")
      ("james" . "1a London Road"))

     address-list
     =>
     (("mary" . "34 Elm Road") ("james" . "1a London Road"))

   The only safe way to update an association list variable when adding
or replacing an entry like this is to `set!' the variable to the
returned value:

     (set! address-list
           (assoc-set! address-list "bob" "11 Newington Avenue"))
     address-list
     =>
     (("bob" . "11 Newington Avenue") ("mary" . "34 Elm Road")
      ("james" . "1a London Road"))

   Because of this slight inconvenience, you may find it more
convenient to use hash tables to store dictionary data.  If your
application will not be modifying the contents of an alist very often,
this may not make much difference to you.

   If you need to keep the old value of an association list in a form
independent from the list that results from modification by `acons',
`assq-set!', `assv-set!' or `assoc-set!', use `list-copy' to copy the
old association list before modifying it.

 -- Scheme Procedure: acons key value alist
 -- C Function: scm_acons (key, value, alist)
     Add a new key-value pair to ALIST.  A new pair is created whose
     car is KEY and whose cdr is VALUE, and the pair is consed onto
     ALIST, and the new list is returned.  This function is _not_
     destructive; ALIST is not modified.

 -- Scheme Procedure: assq-set! alist key val
 -- Scheme Procedure: assv-set! alist key value
 -- Scheme Procedure: assoc-set! alist key value
 -- C Function: scm_assq_set_x (alist, key, val)
 -- C Function: scm_assv_set_x (alist, key, val)
 -- C Function: scm_assoc_set_x (alist, key, val)
     Reassociate KEY in ALIST with VALUE: find any existing ALIST entry
     for KEY and associate it with the new VALUE.  If ALIST does not
     contain an entry for KEY, add a new one.  Return the (possibly
     new) alist.

     These functions do not attempt to verify the structure of ALIST,
     and so may cause unusual results if passed an object that is not an
     association list.


File: guile.info,  Node: Retrieving Alist Entries,  Next: Removing Alist Entries,  Prev: Adding or Setting Alist Entries,  Up: Association Lists

6.7.12.3 Retrieving Alist Entries
.................................

`assq', `assv' and `assoc' find the entry in an alist for a given key,
and return the `(KEY . VALUE)' pair.  `assq-ref', `assv-ref' and
`assoc-ref' do a similar lookup, but return just the VALUE.

 -- Scheme Procedure: assq key alist
 -- Scheme Procedure: assv key alist
 -- Scheme Procedure: assoc key alist
 -- C Function: scm_assq (key, alist)
 -- C Function: scm_assv (key, alist)
 -- C Function: scm_assoc (key, alist)
     Return the first entry in ALIST with the given KEY.  The return is
     the pair `(KEY . VALUE)' from ALIST.  If there's no matching entry
     the return is `#f'.

     `assq' compares keys with `eq?', `assv' uses `eqv?' and `assoc'
     uses `equal?'.  See also SRFI-1 which has an extended `assoc'
     (*note SRFI-1 Association Lists::).

 -- Scheme Procedure: assq-ref alist key
 -- Scheme Procedure: assv-ref alist key
 -- Scheme Procedure: assoc-ref alist key
 -- C Function: scm_assq_ref (alist, key)
 -- C Function: scm_assv_ref (alist, key)
 -- C Function: scm_assoc_ref (alist, key)
     Return the value from the first entry in ALIST with the given KEY,
     or `#f' if there's no such entry.

     `assq-ref' compares keys with `eq?', `assv-ref' uses `eqv?' and
     `assoc-ref' uses `equal?'.

     Notice these functions have the KEY argument last, like other
     `-ref' functions, but this is opposite to what `assq' etc above
     use.

     When the return is `#f' it can be either KEY not found, or an
     entry which happens to have value `#f' in the `cdr'.  Use `assq'
     etc above if you need to differentiate these cases.



Local Variables:
coding: utf-8
End:
